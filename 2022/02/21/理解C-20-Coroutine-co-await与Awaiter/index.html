<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>理解C++20 Coroutine: co_await与Awaiter - uint128&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="uint128&#039;s Blog"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="uint128&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="理解C++20 Coroutine: co_await与Awaiter"><meta property="og:type" content="blog"><meta property="og:title" content="理解C++20 Coroutine: co_await与Awaiter"><meta property="og:url" content="https://uint128.com/2022/02/21/%E7%90%86%E8%A7%A3C-20-Coroutine-co-await%E4%B8%8EAwaiter/"><meta property="og:site_name" content="uint128&#039;s Blog"><meta property="og:description" content="理解C++20 Coroutine: co_await与Awaiter"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://uint128.com/img/og_image.png"><meta property="article:published_time" content="2022-02-20T18:16:20.000Z"><meta property="article:modified_time" content="2022-08-22T09:11:21.035Z"><meta property="article:author" content="uint128.com"><meta property="article:tag" content="uint128"><meta property="article:tag" content="uint128&#039;s blog"><meta property="article:tag" content="uint128.com"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://uint128.com/2022/02/21/%E7%90%86%E8%A7%A3C-20-Coroutine-co-await%E4%B8%8EAwaiter/"},"headline":"uint128's Blog","image":["https://uint128.com/img/og_image.png"],"datePublished":"2022-02-20T18:16:20.000Z","dateModified":"2022-08-22T09:11:21.035Z","author":{"@type":"Person","name":"uint128.com"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"理解C++20 Coroutine: co_await与Awaiter"}</script><link rel="canonical" href="https://uint128.com/2022/02/21/%E7%90%86%E8%A7%A3C-20-Coroutine-co-await%E4%B8%8EAwaiter/"><link rel="alternate" href="/atom.xml" title="uint128&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">uint128&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/cyanray"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-20T18:16:20.000Z" title="2022/2/21 02:16:20">2022-02-21</time>发表</span><span class="level-item"><time dateTime="2022-08-22T09:11:21.035Z" title="2022/8/22 17:11:21">2022-08-22</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile">理解C++20 Coroutine: co_await与Awaiter</h1><div class="content"><p>理解C++20 Coroutine: co_await与Awaiter<br><span id="more"></span></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>这是我学习 C++20 Coroutine 笔记的第二篇，打算做成一个系列，如果感兴趣可以从头开始读：</p>
<ol>
<li><a href="https://uint128.com/2022/02/16/%E7%90%86%E8%A7%A3-C-20-Coroutine-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/">理解 C++20 Coroutine: 协程的概念</a></li>
</ol>
<p>这篇笔记参考的原文是：<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">C++ Coroutines: Understanding operator co_await</a>，更推荐大家直接看原文，因为原文写的就很好，我的笔记大部分都是翻译的原文。</p>
<h2 id="协程提案给我们提供了什么？-What-does-the-Coroutines-TS-give-us"><a href="#协程提案给我们提供了什么？-What-does-the-Coroutines-TS-give-us" class="headerlink" title="协程提案给我们提供了什么？(What does the Coroutines TS give us?)"></a>协程提案给我们提供了什么？(What does the Coroutines TS give us?)</h2><ol>
<li>三个新关键词：<code>co_await</code>、<code>co_yield</code>、<code>co_return</code>。</li>
<li>几个新类型：<ol>
<li><code>coroutine_handle&lt;P&gt;</code></li>
<li><code>coroutine_traits&lt;Ts…&gt;</code></li>
<li><code>suspend_always</code></li>
<li><code>suspend_never</code></li>
</ol>
</li>
<li>一套通用的机制，库的编写者可以使用它与协程交互并自定义协程的行为。</li>
<li>一种使得编写异步代码更简单的语言工具。</li>
</ol>
<p>C++20 协程提案所提供的工具可以被认为是协程版的“低级汇编语言”。这些工具很难被安全地、直接地使用，它们的主要目的是让库的编写者去构建其他开发者可以安全使用的、高度抽象的程序。</p>
<h2 id="编译器和库之间的交互（Compiler-lt-gt-Library-interaction）"><a href="#编译器和库之间的交互（Compiler-lt-gt-Library-interaction）" class="headerlink" title="编译器和库之间的交互（Compiler &lt;-&gt; Library interaction）"></a>编译器和库之间的交互（Compiler &lt;-&gt; Library interaction）</h2><p>协程提案实际上并没有定义协程语义。它没有定义如何产生返回给调用者的值。它没有定义如何处理传递给 co_return 语句的返回值或如何处理从协程传播的异常。它也没有定义协程将会在哪一条线程恢复运行。</p>
<p>取而代之的是，它为库代码指定了一种通用的机制，可以通过实现符合特定接口的类型以定制协程的行为。编译器会生成调用这个类型实例方法的代码。这种方法类似于库编写者可以通过定义 begin()/end() 方法来自定义 range-based for-loop。</p>
<p>事实上，协程提案没有规定任何特定的协程机制语义使得它成为了一个很强大的工具。这允许库的编写者可以为了各种不同的目的，定义不同类型的协程。</p>
<p>举例来说，你可以定义一个协程，它异步地产生一个值；或者定义一个协程，它“懒惰地”（lazily）产生一系列值（即在需要时才计算值，而不是预先计算出整个序列再返回其中一个）；或定义一个协程来简化控制流程，如果 <code>std::optional&lt;T&gt;</code> 的值是 <code>std::nullopt</code>，那么就尽早退出执行。</p>
<p>协程提案定义了两种接口：<strong>Promise 接口</strong>和 <strong>Awaiter 接口</strong>。</p>
<blockquote>
<p>!注意，这里原文用的是 Awaitable 接口，但是我觉得应该用 Awaiter 接口，因为下文提到：“实现了三个方法的类型称为 Awaiter 类型”，那么这三个方法所对应的接口称为 Awaiter 接口会更容易理解，因此我这里采用了“Awaiter 接口”。</p>
<p>这里的接口指的就是面向对象里接口的含义。只要你的类型实现了标准所指定的一系列函数，也就是实现了 Promise 接口 或 Awaiter 接口，那么这个类型就是 Promise type 或 Awaiter type。</p>
</blockquote>
<p><strong>Promise 接口指定了一些方法来控制协程自身的行为。</strong>库的编写者可以自定义当协程被调用时会发生什么、当协程返回时会发生什么（这里的返回既可以指寻常意义的函数返回，也可以指因为未捕获的异常而退出）、以及自定义协程内所有 co_await 或 co_yield 表达式的行为（这里指的是 await_transform 的工作）。</p>
<p><strong>Awaiter 接口指定了一些方法来控制 co_await 表达式的语义。</strong>当一个值被 co_await 时，代码会被翻译成 awaitable 对象的一系列方法的调用。Awaiter 接口允许你：是否挂起当前的协程(1)、当协程已经挂起后执行额外的逻辑来安排协程之后何时恢复执行、在协程恢复执行并产生 co_await 表达式的结果后执行一些逻辑。</p>
<blockquote>
<p>(1).比如一种可以被多次 co_await 的设计，第一次会挂起进行计算并保存计算结果，之后再co_await 都直接返回计算结果而无需挂起</p>
</blockquote>
<h2 id="Awaiter和Awaitable-解释operator-co-await-Awaiters-and-Awaitables-Explaining-operator-co-await"><a href="#Awaiter和Awaitable-解释operator-co-await-Awaiters-and-Awaitables-Explaining-operator-co-await" class="headerlink" title="Awaiter和Awaitable:解释operator co_await(Awaiters and Awaitables: Explaining operator co_await)"></a>Awaiter和Awaitable:解释operator co_await(Awaiters and Awaitables: Explaining operator co_await)</h2><p>操作符 <code>co_await</code> 是一个新的可以作用于一个值的一元操作符，比如说：<code>co_await someValue</code>。</p>
<p><strong>操作符 co_await 只能被用于协程中。</strong> 这是一种“恒真逻辑”（tautology）的思想，因为根据定义，所有包含co_await操作符的函数会被编译成协程。</p>
<blockquote>
<p>其实我更喜欢 C# 的方式，C# 将带有 async 关键词的方法编译为异步函数，通过关键词这样可以一眼看出一个函数是不是异步函数。<br>而 C++ 的这种方式，协程和普通函数的区别就没那么清晰了。<br>我注意到有人提案添加 async 关键词，类似 C#，将有 async 关键词标记的函数编译为协程。并同时将 co_await、co_yield及co_return分别简化为 await、yield、return。<br>这个提案的结果是“没有达成一致认识”，看来是失败了呢。</p>
</blockquote>
<p><strong>一个支持 co_await 操作符的类型被称为 Awaitable 类型(Awaitable type).</strong></p>
<p>请注意一个类型是否可以被 co_await 操作符应用可以依赖于 co_await 表达式出现的上下文。协程所使用的 Promise type 可以使用它的 await_transform 方法来改变 co_await 表达式的含义。</p>
<blockquote>
<p>await_transform 方法我还没有使用过，但是我猜测它可以把一个类型转化为一个 Awaitable 类型。这样一个即使不是 Awaitable 类型（比如std::string），在某些协程里也可以使用： <code>co_await std::string</code> 的用法。</p>
</blockquote>
<p>更具体地说，在需要时，我喜欢使用术语 <strong>Normal Awaitable</strong> 来描述在没有 await_transform 成员的协程上下文中支持 co_await 运算符的类型。而且我喜欢使用术语 <strong>Contextually Awaitable</strong> 来描述一种类型，该类型仅在某些类型的协程的上下文中支持 co_await 运算符，因为协程的 promise 类型中存在 await_transform 方法。</p>
<p>总结：</p>
<ol>
<li><strong>Normal Awaitable</strong>：因为实现了 Awaiter 接口而变得 Awaitable 的类型。</li>
<li><strong>Contextually Awaitable</strong>: 因为 promise type 实现了相关 await_transform 方法而变得 Awaitable 的类型。</li>
</ol>
<p>一个 Awaiter 类型是实现了三个特定方法的类型，这些方法作为 co_await 表达式的一部分被调用，这三个特定方法是：<code>await_ready</code>、<code>await_suspend</code>、<code>await_resume</code>。</p>
<p>请注意，我无耻地从C# async关键词的机制中“借用”了术语 “Awaiter”，该机制是根据 GetAwaiter() 方法实现的，它返回对象的接口类似于C++中Awaiter 的概念。(这里的“我”，是原文的作者，我只是翻译)</p>
<p><strong>请注意，一个类型可以同时是 Awaitable 类型和 Awater 类型。</strong></p>
<blockquote>
<p>实现了这三个方法的类型根据定义自然是一个 Awater type，而 Awaiter 可以被 co_await 关键词应用，天然是 Awaitable type。但是Awaitable type 不一定是 Awater type！比如你可以重载 operator co_await，然后返回一个 Awaiter，这样的类型是 Awaitable type，但是因为没有实现 Awaiter 接口，所以不是 Awaiter type。</p>
</blockquote>
<h2 id="获取-Awaiter-Obtaining-the-Awaiter"><a href="#获取-Awaiter-Obtaining-the-Awaiter" class="headerlink" title="获取 Awaiter (Obtaining the Awaiter)"></a>获取 Awaiter (Obtaining the Awaiter)</h2><p>对于被 co_await 的值，编译器做的第一件事情是生成获取 Awaiter 对象的代码。N4680 第 5.3.8(3) 节列出了一些获取 awaiter 对象的步骤。</p>
<p>让我们假设被 co_await 的协程的 Promise type 是 <code>P</code>，而且变量<code>promise</code> 是当前协程的 Promise object 的左值引用。</p>
<p>如果 Promise type <code>P</code> 有一个名为 await_transform 的成员函数，那么表达式 <code>&lt;expr&gt;</code> 首先被传入到函数调用 <code>promise.await_transform(&lt;expr&gt;)</code> 中以获取 Awaitable 值，<code>awaitable</code>。</p>
<p>如果没有 await_transform 成员函数，那么表达式 <code>&lt;expr&gt;</code> 的结果被直接认为是 Awaitable 对象，<code>awaitable</code>。</p>
<p>然后，如果 Awaitable 对象 <code>awaitable</code> 有一个 <code>operator co_await</code> 操作符重载，那么操作符重载会被调用来获取 Awaiter 对象。反之，<code>awaitable</code> 将用作 awaiter 对象。</p>
<p>如果把这些流程写成代码，那么两个函数 <code>get_awaitable()</code> 和 <code>get_awaiter()</code> 可能看起来像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get_awaitable</span><span class="params">(P&amp; promise, T&amp;&amp; expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_any_await_transform_member_v&lt;P&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> promise.<span class="title">await_transform</span><span class="params">(<span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(expr))</span></span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get_awaiter</span><span class="params">(Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_member_operator_co_await_v&lt;Awaitable&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;<span class="params">(awaitable)</span>.<span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (has_non_member_operator_co_await_v&lt;Awaitable&amp;&amp;&gt;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> <span class="built_in">co_await</span>(<span class="built_in">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一段主要是想表达对于 <code>co_await &lt;expr&gt;</code> 这么一行代码，其中这个 <code>&lt;expr&gt;</code> 可以是很多很多种情况。<br>比如 <code>&lt;expr&gt;</code> 可以是一个 Awaiter type 或者 Awaitable type 的 object，那么肯定行得通。<br>又比如 <code>&lt;expr&gt;</code> 可以是一个函数调用，但是它的返回值是 Awaitable type，那么也行得通！<br>再极端点，<code>&lt;expr&gt;</code> 既不是 Awaiter type 也不是 Awaitable type，但是因为协程的 Promise type 实现了相关的 <code>await_transform()</code> 函数，那么这个 <code>co_await &lt;expr&gt;</code> 也是合法的代码。</p>
</blockquote>
<h2 id="Awaiting-the-Awaiter"><a href="#Awaiting-the-Awaiter" class="headerlink" title="Awaiting the Awaiter"></a>Awaiting the Awaiter</h2><blockquote>
<p>这个标题还真不知道怎么翻译好。这一部分主要讲解 C++ 编译器是如何把 <code>co_await &lt;expr&gt;</code> 翻译成一系列 Awaiter 接口的函数调用的。</p>
</blockquote>
<p>我们假设将 <code>&lt;expr&gt;</code> 的结果转化为 Awaiter 的逻辑可以封装成上面所说的两个函数，那么对于代码 <code>co_await &lt;expr&gt;</code> 的语义可以被粗糙地翻译为以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaitable = <span class="built_in">get_awaitable</span>(promise, <span class="built_in">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaiter = <span class="built_in">get_awaiter</span>(<span class="built_in">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.<span class="built_in">await_ready</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">handle_t</span> = std::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="type">await_suspend_result_t</span> =</span><br><span class="line">      <span class="keyword">decltype</span>(awaiter.<span class="built_in">await_suspend</span>(<span class="type">handle_t</span>::<span class="built_in">from_promise</span>(p)));</span><br><span class="line"></span><br><span class="line">    &lt;suspend-coroutine&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_void_v&lt;<span class="type">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      awaiter.<span class="built_in">await_suspend</span>(<span class="type">handle_t</span>::<span class="built_in">from_promise</span>(p));</span><br><span class="line">      &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">static_assert</span>(</span><br><span class="line">         std::is_same_v&lt;<span class="type">await_suspend_result_t</span>, <span class="type">bool</span>&gt;,</span><br><span class="line">         <span class="string">&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (awaiter.<span class="built_in">await_suspend</span>(<span class="type">handle_t</span>::<span class="built_in">from_promise</span>(p)))</span><br><span class="line">      &#123;</span><br><span class="line">        &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;resume-point&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.<span class="built_in">await_resume</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法 <code>await_suspend()</code> 根据返回值类型可以分为两个版本，void 版本和bool 版本。其中，void 版本无条件地将执行转移回 caller/resumer。而bool 版本允许 awaiter 对象根据条件选择是否立即恢复协程的执行，而不返回到 caller/resumer。</p>
<p>bool版本的 <code>await_suspend()</code> 方法可以被用于这种情况：awaiter 可以异步地进行计算，但有时也想同步地执行。</p>
<p>在 <code>&lt;suspend-coroutine&gt;</code> 节点，编译器会生成一些代码来保存当前协程的状态并准备协程的恢复。这包括保存恢复点的地址以及将寄存器中的值保存到协程帧的内存中。</p>
<p>在 <code>&lt;suspend-coroutine&gt;</code> 的操作完成之后，当前的协程就被认为是处于挂起状态。你能观察挂起的协程的第一个点在 await_suspend() 的调用里。一旦协程被挂起，它就可以被恢复或者销毁。</p>
<p>函数 <code>await_suspend()</code> 的责任是安排协程在未来的恢复（或销毁）。注意，从 <code>await_suspend()</code> 返回 false 算作是安排协程在当前线程立刻恢复。</p>
<p>函数 <code>await_ready()</code> 的目的是允许你避免 <code>&lt;suspend-coroutine&gt;</code> 操作的消耗，在某些情况，当你已知要同步地进行，就不需要挂起协程再恢复。</p>
<p>在 <code>&lt;return-to-caller-or-resumer&gt;</code> 节点，执行会被转移回 caller/resumer，当前栈帧弹出，但是保持协程帧活跃。</p>
<p>当挂起的协程最终被恢复，则在 <code>&lt;resume-point&gt;</code> 恢复执行。</p>
<p>函数 await_resume() 的返回值类型就是 co_await 表达式的结果类型。函数 await_resume() 也可以抛出异常，来向外传播 co_await 表达式中的异常。</p>
<p>请注意，如果一个异常在调用 await_suspend() 时传播出来，那么协程会自动地恢复，并且不会调用 await_resume()。</p>
<h2 id="协程句柄-Coroutine-Handles"><a href="#协程句柄-Coroutine-Handles" class="headerlink" title="协程句柄(Coroutine Handles)"></a>协程句柄(Coroutine Handles)</h2><p>类型 <code>coroutine_handle&lt;P&gt;</code> 表示协程帧的一个非拥有句柄（non-owning handle），可以通过它来恢复协程的执行或销毁协程帧。它也可以被用来访问协程的 promise object。</p>
<blockquote>
<p>什么是 non-owning handle？我不知道怎么翻译好。</p>
</blockquote>
<p>概括的说，协程句柄有这些接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">coroutine_handle</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">coroutine_handle</span>&lt;<span class="type">void</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="type">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">coroutine_handle</span> : coroutine_handle&lt;<span class="type">void</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Promise&amp; <span class="title">promise</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(Promise&amp; promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="type">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你实现一个 Awaiter type 时，你将会用到 coroutine_handle 里一个关键的 resume 方法。当某些操作完成时，你想要恢复协程的执行，就调用resume 方法。resume 方法将会在遇到下一个 <code>&lt;return-to-caller-or-resumer&gt;</code> 节点时返回（有两种情况：1.再次遇到 co_await，并且将会再次挂起协程； 2.执行到协程的末尾；）。</p>
<p>destroy 方法会销毁协程帧，调用所有作用范围内的变量的析构函数，并且释放协程帧所用的内存。你通常不需要（而且应该尽量避免）去调用 destroy 函数，除非你是一个库的作者，正在实现协程的 Promise type。通常来说，协程帧会被某种 RAII 类型所持有，并且来自协程调用的返回值。所以调用destroy 而没有和 RAII 对象协作的话，会导致双重析构的BUG。</p>
<p>promise 方法返回当前协程的 promise object 的引用。和 destroy 方法一样，它通常只有在你是协程的 promise type 的作者时才会用到。</p>
<p>通常来说，对于绝大多数的 <strong>Normally Awaitable</strong> 类型，应该使用 <code>coroutine_handle&lt;void&gt;</code> 作为 <code>await_suspend()</code> 方法的参数类型，而不是 <code>coroutine_handle&lt;Promise&gt;</code>。如果考虑为某些协程 Promise type 做特别实现，才使用 <code>coroutine_handle&lt;Promise&gt;</code>。</p>
<p>方法 <code>coroutine_handle&lt;P&gt;::from_promise(P&amp; promise)</code> 允许你从协程的 Promise object 的引用重新构造 coroutine handle。请注意，你必须确保类型 P 和具体协程的 promise type 相匹配。如果尝试构造一个 <code>cotoutine_handle&lt;Base&gt;</code> 而具体协程的 promise type 是 Derived 会导致未定义行为。</p>
<p>方法 address()/from_address() 允许你将 coroutine handle 转化为/转化自 一个 void* 指针。</p>
<p>这主要是为了允许作为“上下文”参数传递到现有的 C-Style API，你在某些情况下实现 Awaiter type 时才会发现它的用处。不过，在我所发现的大多数案例里，需要额外传递信息给这个“上下文”参数。所以我通常将 coroutine_handle 储存在一个 struct 中，然后把 struct 的指针传递给这个“上下文”参数，而不是使用 address 的返回值。</p>
<h2 id="无需同步的异步代码（Synchronisation-free-async-code）"><a href="#无需同步的异步代码（Synchronisation-free-async-code）" class="headerlink" title="无需同步的异步代码（Synchronisation-free async code）"></a>无需同步的异步代码（Synchronisation-free async code）</h2><p>co_await 操作符的一个强大的设计特性是可以在<em>协程暂停后</em>且<em>将执行返回到caller/resumer之前</em>执行代码。</p>
<p>这允许 Awaiter object 在协程已经挂起后去初始化异步操作，将已经挂起的协程的 coroutine_handle 传入给异步操作。当异步操作完成后，这可以安全地恢复（可能在另一条线程）而不需要额外的同步。</p>
<p>当协程恢复之后的第一件事情是调用 await_resume 来获取返回值，并且通常立即销毁 Awaiter object（举例说，await_suspend 里使用 this 指针）。协程是有可能在await_suspend返回之前就运行到结尾、销毁协程和 promise object的。</p>
<p>所以，在 await_suspend 方法里，一旦协程有可能在另一条线程恢复，你需要确保避免访问 this 指针和协程的promise object(通过.promise()方法)，因为它们可能都已经被销毁了。通常来说，在异步操作开始之后和协程已经被安排恢复，在await_suspend方法里你可以安全地访问的唯一东西就是await_suspend的局部变量。</p>
<blockquote>
<p>我看的一脸懵逼，没有相关编程经验，不知道到底说的什么情况。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原文作者很详细地讲解了 <code>co_await &lt;expr&gt;</code> 语句是如何被翻译成 Awaiter 接口的调用的。我感觉原文不适合给初学者了解 C++ 协程，它非常枯燥，而且有很多新概念（我也是写了一些协程代码后，再回头看这篇文章，才顺利地看明白了）。我觉得原文更适合那些希望了解 C++ 协程工作细节的人，绝对值得多次阅读。</p>
<h3 id="Awaiter-type"><a href="#Awaiter-type" class="headerlink" title="Awaiter type"></a>Awaiter type</h3><p>实现了 Awaiter 接口的类型。</p>
<p>它用三个函数控制 co_await 表达式如何工作。</p>
<ol>
<li><code>bool await_ready();</code> : 表示 co_await 是否要挂起，false -&gt; 挂起。</li>
<li><code>void/bool await_suspend(coroutine_handle&lt;P&gt;);</code> : 在这个函数里安排何时恢复协程的执行（通过调用 <code>resume()</code> 方法）。</li>
<li><code>T await_resume()</code> : 在这个函数返回执行的返回值。类型 <code>T</code> 表示 <code>co_await &lt;expr&gt;</code> 表达式的类型。</li>
</ol>
<h3 id="Awaitable-type"><a href="#Awaitable-type" class="headerlink" title="Awaitable type"></a>Awaitable type</h3><p>可以被 <code>co_await</code> 的类型。（可以是 Awaiter type 也可以是重载了 operator co_await 的类型）</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>理解C++20 Coroutine: co_await与Awaiter</p><p><a href="https://uint128.com/2022/02/21/理解C-20-Coroutine-co-await与Awaiter/">https://uint128.com/2022/02/21/理解C-20-Coroutine-co-await与Awaiter/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>uint128.com</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/03/02/%E7%90%86%E8%A7%A3C-20-Coroutine-promise-type/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">理解C++20 Coroutine: Promise type</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/16/%E7%90%86%E8%A7%A3-C-20-Coroutine-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/"><span class="level-item">理解 C++20 Coroutine: 协程的概念</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "7c35c66b9f5b923e277ad464dcb3b150",
            repo: "cyanray.github.io",
            owner: "cyanray",
            clientID: "53e3c578fcb7b7b1a4da",
            clientSecret: "74433ee77d6e13fd635b82add519e143ac791726",
            admin: ["cyanray"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#协程提案给我们提供了什么？-What-does-the-Coroutines-TS-give-us"><span class="level-left"><span class="level-item">1</span><span class="level-item">协程提案给我们提供了什么？(What does the Coroutines TS give us?)</span></span></a></li><li><a class="level is-mobile" href="#编译器和库之间的交互（Compiler-lt-gt-Library-interaction）"><span class="level-left"><span class="level-item">2</span><span class="level-item">编译器和库之间的交互（Compiler &lt;-&gt; Library interaction）</span></span></a></li><li><a class="level is-mobile" href="#Awaiter和Awaitable-解释operator-co-await-Awaiters-and-Awaitables-Explaining-operator-co-await"><span class="level-left"><span class="level-item">3</span><span class="level-item">Awaiter和Awaitable:解释operator co_await(Awaiters and Awaitables: Explaining operator co_await)</span></span></a></li><li><a class="level is-mobile" href="#获取-Awaiter-Obtaining-the-Awaiter"><span class="level-left"><span class="level-item">4</span><span class="level-item">获取 Awaiter (Obtaining the Awaiter)</span></span></a></li><li><a class="level is-mobile" href="#Awaiting-the-Awaiter"><span class="level-left"><span class="level-item">5</span><span class="level-item">Awaiting the Awaiter</span></span></a></li><li><a class="level is-mobile" href="#协程句柄-Coroutine-Handles"><span class="level-left"><span class="level-item">6</span><span class="level-item">协程句柄(Coroutine Handles)</span></span></a></li><li><a class="level is-mobile" href="#无需同步的异步代码（Synchronisation-free-async-code）"><span class="level-left"><span class="level-item">7</span><span class="level-item">无需同步的异步代码（Synchronisation-free async code）</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Awaiter-type"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Awaiter type</span></span></a></li><li><a class="level is-mobile" href="#Awaitable-type"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">Awaitable type</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-11T06:30:05.000Z">2023-07-11</time></p><p class="title"><a href="/2023/07/11/%E5%9F%BA%E4%BA%8EObjectARX-NET%E7%9A%84AutoCAD%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">基于ObjectARX .NET的AutoCAD二次开发：项目配置</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-29T09:02:24.000Z">2023-04-29</time></p><p class="title"><a href="/2023/04/29/C-Concepts-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7/">C++ Concepts 的两个技巧</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-06T15:23:32.000Z">2023-03-06</time></p><p class="title"><a href="/2023/03/06/Modern-CMake-%E5%AE%9E%E8%B7%B5/">Modern CMake 实践</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-07T18:40:09.000Z">2023-01-08</time></p><p class="title"><a href="/2023/01/08/%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/">牛顿插值法的 Matlab 实现</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-07T18:38:42.000Z">2023-01-08</time></p><p class="title"><a href="/2023/01/08/%E5%A4%9A%E5%85%83%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/">多元牛顿迭代法的 Matlab 实现</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://yuanxingxing-yxx.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">星星的博客</span></span><span class="level-right"><span class="level-item tag">yuanxingxing-yxx.github.io</span></span></a></li><li><a class="level is-mobile" href="http://quosimodo.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">卡西莫多の礼物</span></span><span class="level-right"><span class="level-item tag">quosimodo.cn</span></span></a></li><li><a class="level is-mobile" href="https://blog.icepie.net/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">icepie&#039;s blog</span></span><span class="level-right"><span class="level-item tag">blog.icepie.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/sherlson" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">sherlson&#039;s blog</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="http://blog.devilwst.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">小生的技术成长路线</span></span><span class="level-right"><span class="level-item tag">blog.devilwst.top</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">uint128&#039;s Blog</a><p class="is-size-7"><span>&copy; 2023 uint128.com</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>