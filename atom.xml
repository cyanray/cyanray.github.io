<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>uint128&#39;s Blog</title>
  
  <subtitle>none</subtitle>
  <link href="https://uint128.com/atom.xml" rel="self"/>
  
  <link href="https://uint128.com/"/>
  <updated>2023-11-16T07:36:03.944Z</updated>
  <id>https://uint128.com/</id>
  
  <author>
    <name>uint128.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过Nginx创建WebDAV服务同步Zotero文献</title>
    <link href="https://uint128.com/2023/11/16/%E9%80%9A%E8%BF%87Nginx%E5%88%9B%E5%BB%BAWebDAV%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5Zotero%E6%96%87%E7%8C%AE/"/>
    <id>https://uint128.com/2023/11/16/%E9%80%9A%E8%BF%87Nginx%E5%88%9B%E5%BB%BAWebDAV%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5Zotero%E6%96%87%E7%8C%AE/</id>
    <published>2023-11-16T06:43:46.000Z</published>
    <updated>2023-11-16T07:36:03.944Z</updated>
    
    <content type="html"><![CDATA[<p>Zotero 提供了免费的 300MB 同步空间，文献多了之后存不下了。好在 Zotero 还支持通过 WebDAV 的方式同步文件，这篇文章分享一下具体的部署过程。</p><span id="more"></span><h2 id="设备选择"><a href="#设备选择" class="headerlink" title="设备选择"></a>设备选择</h2><p>首先，需要一台装有 Linux 系统的电脑，云主机或者 NAS 都可以。我部署 WebDAV 的设备是一台旧办公本，装上了 Ubuntu 系统放在宿舍里 7x24h 运行着，算是一台服务器了。因为我需要同步文献的设备总是连接着校园网，所以也不需要公网 IP。</p><p>如果读者的设备不能总在同一个局域网，那么你只能考虑有公网 IP 的 NAS 或者云主机了。</p><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>通过包管理器 apt 安装 nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nginx-full</span><br></pre></td></tr></table></figure><p>安装好之后可以通过 curl 检测下 nginx 是不是装好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost</span><br></pre></td></tr></table></figure><p>如果显示下面的内容，能找到“Welcome to nginx!”的句子，就说明安装成功了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl http://localhost</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">html</span> &#123; <span class="attribute">color</span>-scheme: light dark; &#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123; <span class="attribute">width</span>: <span class="number">35em</span>; <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css"><span class="attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Commercial support is available at</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也有可能提示找不到 curl，那么可以用包管理器装一下 curl 然后再试一次。执行： <code>sudo apt-get install curl</code> 安装 curl。</p></blockquote><h2 id="配置-WebDAV"><a href="#配置-WebDAV" class="headerlink" title="配置 WebDAV"></a>配置 WebDAV</h2><p>接下来，需要使用编辑器 nano 在 Nginx 的配置文件目录中创建一个配置文件，配置 WebDAV 服务的相关设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/conf.d/webdav.conf</span><br></pre></td></tr></table></figure><blockquote><p>如果你的 Linux 系统有 GUI 界面，可以用 VSCode 等可视化编辑器操作</p></blockquote><p>往里面填入以下配置文件内容，可以根据情况修改端口(比如 17780 可以改成别的端口)、路径等参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 17780;</span><br><span class="line">    listen [::]:17780;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/dav/webdav_root;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dav allowed method</span></span><br><span class="line">        dav_methods     PUT DELETE MKCOL COPY MOVE;</span><br><span class="line">        <span class="comment"># Allow current scope perform specified DAV method</span></span><br><span class="line">        dav_ext_methods PROPFIND OPTIONS;</span><br><span class="line"></span><br><span class="line">        dav_access     user:rw group:rw all:r;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Temporary folder</span></span><br><span class="line">        client_body_temp_path   /var/www/dav/tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># MAX size of uploaded file, 0 mean unlimited</span></span><br><span class="line">        client_max_body_size    0;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Allow autocreate folder here if necessary</span></span><br><span class="line">        create_full_put_path    on;</span><br><span class="line"></span><br><span class="line">        auth_basic “Restricted”;</span><br><span class="line">        auth_basic_user_file /var/www/dav/.htpasswd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按下快捷键 Ctrl+O 保存退出。</p><p>执行以下指令，让 Nginx 重新载入所有配置文件。如果没有任何输出，说明配置文件的内容正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>现在，需要创建一些目录。这里的 <code>-p</code> 参数的作用是递归地创建目录，能够同时创建一条路径里所有不存在的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /var/www/dav/tmp</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /var/www/dav/webdav_root</span><br></pre></td></tr></table></figure><p>然后，需要改变这些目录的拥有者为 www-data。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R www-data /var/www/dav/tmp</span><br><span class="line">sudo <span class="built_in">chown</span> -R www-data /var/www/dav/webdav_root</span><br></pre></td></tr></table></figure><h2 id="创建认证用户"><a href="#创建认证用户" class="headerlink" title="创建认证用户"></a>创建认证用户</h2><p>这里要用到 Apache Utils，通过包管理器安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2-utils</span><br></pre></td></tr></table></figure><p>执行下面的指令，他会创建一个 .htpasswd 文件。其中 exampleuser 是用户名，将它改成你自己的英文名字。回车执行之后，会提示你输入两次密码，这是认证用的密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo htpasswd -c /var/www/dav/.htpasswd exampleuser</span><br></pre></td></tr></table></figure><p>如果一切顺利，执行下面的指令，可以看到一对用冒号分隔的用户名和密码哈希。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /var/www/dav/.htpasswd</span><br></pre></td></tr></table></figure><p>内容结构类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login:password</span><br></pre></td></tr></table></figure><h2 id="在-Zotero-中测试"><a href="#在-Zotero-中测试" class="headerlink" title="在 Zotero 中测试"></a>在 Zotero 中测试</h2><p>最后在 Zotero 里同步方式选择 WebDAV 就好了。</p><p>如果 Zotero 的同步没有反应（表现在没有新文件出现在 <code>/var/www/dav/webdav_root</code> 里），需要关闭 Zotero 的自动同步，然后手动点击同步按钮同步一次，这样可以强制 Zotero 进行一次完全同步。同步完成后再把自动同步开回来。</p><h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><p>上面 WebDAV 服务所涉及的目录都需要有执行权限，你可以通过 chmod 指令给相关目录赋予执行权限。</p><p>比如我的相关目录都改到了 /home/ubuntu 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x /home/ubuntu/dav</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /home/ubuntu/dav/tmp</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /home/ubuntu/dav/webdav_root</span><br></pre></td></tr></table></figure><p>如果还有其他错误，可以通过查看 Nginx 的错误日志进一步排查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /var/log/nginx/error.log</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zotero 提供了免费的 300MB 同步空间，文献多了之后存不下了。好在 Zotero 还支持通过 WebDAV 的方式同步文件，这篇文章分享一下具体的部署过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>纯真而不欠闻达，善良而不失坚强</title>
    <link href="https://uint128.com/2023/11/02/%E7%BA%AF%E7%9C%9F%E8%80%8C%E4%B8%8D%E6%AC%A0%E9%97%BB%E8%BE%BE%EF%BC%8C%E5%96%84%E8%89%AF%E8%80%8C%E4%B8%8D%E5%A4%B1%E5%9D%9A%E5%BC%BA/"/>
    <id>https://uint128.com/2023/11/02/%E7%BA%AF%E7%9C%9F%E8%80%8C%E4%B8%8D%E6%AC%A0%E9%97%BB%E8%BE%BE%EF%BC%8C%E5%96%84%E8%89%AF%E8%80%8C%E4%B8%8D%E5%A4%B1%E5%9D%9A%E5%BC%BA/</id>
    <published>2023-11-02T15:56:51.000Z</published>
    <updated>2023-11-16T06:42:36.578Z</updated>
    
    <content type="html"><![CDATA[<p>纯真而不欠闻达，善良而不失坚强，把生命高举在尘俗之上，又融化于社会之中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;纯真而不欠闻达，善良而不失坚强，把生命高举在尘俗之上，又融化于社会之中。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于ObjectARX .NET的AutoCAD二次开发：项目配置</title>
    <link href="https://uint128.com/2023/07/11/%E5%9F%BA%E4%BA%8EObjectARX-NET%E7%9A%84AutoCAD%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://uint128.com/2023/07/11/%E5%9F%BA%E4%BA%8EObjectARX-NET%E7%9A%84AutoCAD%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-11T06:30:05.000Z</published>
    <updated>2023-07-11T17:29:25.019Z</updated>
    
    <content type="html"><![CDATA[<p>ObjectARX 是 AutoCAD 的开发环境，提供面向对象的 C++ 以及 .NET 编程接口。本文将介绍两种配置 Visual Studio 项目的方法，包括不使用 Wizard 的方法。<br><span id="more"></span></p><h2 id="🔗开发目标"><a href="#🔗开发目标" class="headerlink" title="🔗开发目标"></a>🔗开发目标</h2><p>在基于 ObjectARX .NET API的 AutoCAD 二次开发中，最终需要得到的是一个（或若干个） <strong>.dll 文件</strong>。在 AutoCAD 中使用 <strong>NETLOAD</strong> 指令加载这个 <strong>.dll</strong> 文件，就可以导入包含在其中的 <strong>指令</strong>，从而扩展 AutoCAD 的功能。这些指令具体做什么工作都是自己编写代码实现的，名字也是自己取的，使用的时候和执行 AutoCAD 的内置指令没有区别。</p><p>如果你有一定的 C# 语言的程序开发基础，那么你应该已经联想到你需要一个类型为 <strong>类库</strong>(class library) 的项目，因为它的编译产物正是 <strong>.dll</strong> 文件。下文中我会介绍两种创建这个项目的方法：一种是基于 <strong>AutoCAD DotNet Wizard</strong> 的向导式创建方法，这个向导会询问你 ObjectARX 与 AutoCAD 的安装位置，自动完成项目的<strong>依赖引用</strong>与<strong>调试</strong>设置；另一种是创建普通的类库项目，然后通过 Nuget 或手动编辑的方式完成<strong>依赖引用</strong>的设置。</p><h2 id="🔗前期准备"><a href="#🔗前期准备" class="headerlink" title="🔗前期准备"></a>🔗前期准备</h2><h3 id="📖安装-Visual-Studio"><a href="#📖安装-Visual-Studio" class="headerlink" title="📖安装 Visual Studio"></a>📖安装 Visual Studio</h3><p>网上教程很多，这里不再介绍，注意你只需要在 Visual Studio Installer 里勾选 <strong>.NET 桌面开发</strong> 即可。</p><blockquote><p>Visual Studio Installer 从 Visual Studio 2019 版本开始有（如果我没记错的话），更旧的版本应该是默认安装 .NET 桌面开发的。</p></blockquote><p>我个人是推荐采用最新版本的 Visual Studio。虽然这可能会导致你无法使用 AutoCAD DotNet Wizard，因为它同时要求了 Visual Studio 与 AutoCAD 的版本。比如 AutoCAD 2023 DotNet Wizard，要求 AutoCAD 2023 以及 Visual Studio 2019。如果你使用的是早期的 AutoCAD 版本，可能会同时要求你使用非常古老的 Visual Studio，这非常的不推荐。</p><p>下文会介绍不使用 AutoCAD DotNet Wizard 的方法，采用此方法可以不考虑 Visual Studio 的版本，请直接安装最新版本，以获得最佳的开发体验。</p><h3 id="📖下载并解压-ObjectARX"><a href="#📖下载并解压-ObjectARX" class="headerlink" title="📖下载并解压 ObjectARX"></a>📖下载并解压 ObjectARX</h3><p>请根据你的操作系统（Windows Or Mac）以及电脑上的 AutoCAD 版本，在这个链接 <a href="https://www.autodesk.com/developer-network/platform-technologies/autocad/objectarx-download">https://www.autodesk.com/developer-network/platform-technologies/autocad/objectarx-download</a> 里下载 ObjectARX。</p><blockquote><p>这个页面在搜索引擎中可能搜索不到，因为它是填写了邮箱之后跳转而来的。</p></blockquote><p>ObjectARX 没有安装过程，下载好之后运行会提示需要解压，解压得到的目录就是 ObjectARX 本身，这个目录的名字类似于： <strong>ObjectARX_for_AutoCAD_2024_Win_64bit_dlm</strong>。</p><h3 id="📖下载并安装-AutoCAD-DotNet-Wizard（可选）"><a href="#📖下载并安装-AutoCAD-DotNet-Wizard（可选）" class="headerlink" title="📖下载并安装 AutoCAD DotNet Wizard（可选）"></a>📖下载并安装 AutoCAD DotNet Wizard（可选）</h3><p>Wizard 可以在链接 <a href="https://www.autodesk.com/developer-network/platform-technologies/autocad">https://www.autodesk.com/developer-network/platform-technologies/autocad</a> 的<strong>最下面</strong>，Tools 一栏里找到。（请下载 <strong>AutoCAD DotNet Wizard</strong> 而不是 AutoCAD Wizard）</p><p>上面提到 AutoCAD DotNet Wizard 同时要求了 Visual Studio 与 AutoCAD 的版本，但其实安装程序只会检测你电脑上所安装的 Visual Studio 是否满足版本要求，因此可以只根据 Visual Studio 的版本来选择 Wizard 的版本。比如 Wizard 2024 要求 Visual Studio 2022，Wizard 2023 要求 Visual Studio 2019（有一个对应关系，可以逐个版本下载，看看哪个能装上）。</p><h2 id="🔗使用-Wizard-创建项目"><a href="#🔗使用-Wizard-创建项目" class="headerlink" title="🔗使用 Wizard 创建项目"></a>🔗使用 Wizard 创建项目</h2><p>打开 Visual Studio 创建项目的时候能看到 AutoCAD CSharp plug-in，按照步骤创建即可。</p><p><img src="./wizard_1.png" alt=""></p><p>如下图所示，向导会询问两个路径，第一个填 ObjectARX 的 inc 目录，比如我填写的是： <strong>D:\ObjectARX_for_AutoCAD_2024_Win_64bit_dlm\inc</strong>。第二个路径填写的是 AutoCAD 的安装路径（包含 acad.exe）。</p><p><img src="./wizard_2.png" alt=""></p><p>创建好项目后直接开始调试，调试器会启动 AutoCAD，此时注意到 AutoCAD 本身也处于调试模式。在加载插件之前，设置的断点会提示无法命中，如下图。</p><p><img src="./wizard_3.png" alt=""></p><p>这是因为插件还没有被 AutoCAD 载入，在 AutoCAD 中新建一个图纸，然后执行 NETLOAD 命令，选择编译出来的 .dll 文件，就会注意到断点可以命中了。执行 MyCommand 指令，断点成功命中。</p><h2 id="🔗手动配置项目"><a href="#🔗手动配置项目" class="headerlink" title="🔗手动配置项目"></a>🔗手动配置项目</h2><p>首先创建一个 <strong>Class Library (.NET Framework)</strong> 项目，注意必须是带有 .NET Framework 的才可以。</p><p><img src="./manual_1.png" alt=""></p><h3 id="📖设置依赖引用"><a href="#📖设置依赖引用" class="headerlink" title="📖设置依赖引用"></a>📖设置依赖引用</h3><h4 id="方法-1：从-ObjectARX-的文件进行设置"><a href="#方法-1：从-ObjectARX-的文件进行设置" class="headerlink" title="方法 1：从 ObjectARX 的文件进行设置"></a>方法 1：从 ObjectARX 的文件进行设置</h4><p>如下图所示，右键项目中的 <strong>References</strong>（引用），选择 <strong>Add Reference</strong>（添加引用）。</p><blockquote><p>由于我的 Visual Studio 是英文，菜单选项的中文译名依赖回忆，因此可能不准确。</p></blockquote><p><img src="./manual_2.png" alt=""></p><p>展开 <strong>Browse</strong>（浏览）页面，然后点击 <strong>Browse</strong>（浏览）按钮进行选择。</p><p><img src="./manual_3.png" alt=""></p><p>导航到 ObjectARX 的 inc 目录，选择 “AcMgd.dll”、”AcCoreMgd.dll” 与 “AcDbMgd.dll” 三个 .dll 文件。</p><p><img src="./manual_4.png" alt=""></p><p>至此，依赖引用设置完成。</p><h4 id="方法-2-使用-NuGet"><a href="#方法-2-使用-NuGet" class="headerlink" title="方法 2: 使用 NuGet"></a>方法 2: 使用 NuGet</h4><p>如下图所示，右键项目中的 <strong>References</strong>（引用），选择 <strong>Manage NuGet Pacakages</strong>（管理 NuGet 包）。</p><p><img src="./manual_nuget_1.png" alt=""></p><p>在 <strong>Browse</strong> 页面中，搜索关键词 “AutoCAD”，在搜索结果中选择 “AutoCAD.NET”。注意右侧可以选择版本，请根据你的 AutoCAD 版本进行选择。比如图中所选择的版本 “24.1.51000”，从下方的 Description 中可以发现它对应的是 AutoCAD 2022。</p><p><img src="./manual_nuget_2.png" alt=""></p><p>选择正确的版本后，点击 <strong>Install</strong>，完成依赖配置。</p><h3 id="📖设置调试方法"><a href="#📖设置调试方法" class="headerlink" title="📖设置调试方法"></a>📖设置调试方法</h3><p>如图，点击 <strong>调试按钮</strong> 右边的 <strong>倒三角按钮</strong> 展开菜单，选择菜单中的 <strong>Debug Properties</strong> (调试属性)。</p><p><img src="./manual_debug_1.png" alt=""></p><p>如图，将 <strong>Start action</strong> 修改为 <strong>Start external program</strong>（启动外部程序），路径填写为 AutoCAD 安装目录下的 acad.exe 的路径。</p><p><img src="./manual_debug_2.png" alt=""></p><p>至此，调试方法设置完毕。</p><h3 id="📖创建基本代码"><a href="#📖创建基本代码" class="headerlink" title="📖创建基本代码"></a>📖创建基本代码</h3><p>这里的代码来自 Wizard 生成的项目，去掉了大部分注释（但其实那些注释还挺有用的，有助于了解这些代码在做什么）并略作修改。</p><p>创建一个 .cs 文件，命名为 “MyPlugin.cs”，内容如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: ExtensionApplication(typeof(ClassLibrary.MyPlugin))</span>]</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ClassLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlugin</span> : <span class="title">IExtensionApplication</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> IExtensionApplication.Initialize()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Initialize your plug-in application here</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IExtensionApplication.Terminate()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Do plug-in application clean up here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意把代码中的 “ClassLibrary” 修改为你自己项目的命名空间</p><p>再创建另一个 .cs 文件，命名为 MyCommand.cs”，内容如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Colors;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: CommandClass(typeof(ClassLibrary.MyCommands))</span>]</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ClassLibrary</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCommands</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">CommandMethod(<span class="string">&quot;MyCommand&quot;</span>, CommandFlags.Modal)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyCommand</span>() <span class="comment">// This method can have any name</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Document doc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">            Editor ed;</span><br><span class="line">            <span class="keyword">if</span> (doc != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ed = doc.Editor;</span><br><span class="line">                ed.WriteMessage(<span class="string">&quot;Hello, this is your first command.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个带有 “MyCommand” 命令的 AutoCAD 插件项目配置完毕。</p><h2 id="🔗最后"><a href="#🔗最后" class="headerlink" title="🔗最后"></a>🔗最后</h2><p>受限于写作经验，本文可能仍有不足，恳请批评指正。如果想转载本文，请在评论区或邮件联系我。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ObjectARX 是 AutoCAD 的开发环境，提供面向对象的 C++ 以及 .NET 编程接口。本文将介绍两种配置 Visual Studio 项目的方法，包括不使用 Wizard 的方法。&lt;br&gt;</summary>
    
    
    
    
    <category term="AutoCAD" scheme="https://uint128.com/tags/AutoCAD/"/>
    
    <category term="CSharp" scheme="https://uint128.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C++ Concepts 的两个技巧</title>
    <link href="https://uint128.com/2023/04/29/C-Concepts-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7/"/>
    <id>https://uint128.com/2023/04/29/C-Concepts-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7/</id>
    <published>2023-04-29T09:02:24.000Z</published>
    <updated>2023-04-29T09:35:53.810Z</updated>
    
    <content type="html"><![CDATA[<p>其实是 C++ 模板的技巧，本文包含两个方面：实现模板函数的“偏特化”的效果，以及阻止字符串字面量隐式转换成 bool。<br><span id="more"></span></p><h2 id="模板函数“偏特化”"><a href="#模板函数“偏特化”" class="headerlink" title="模板函数“偏特化”"></a>模板函数“偏特化”</h2><p>模板函数是不能偏特化的，模板类偏特化的语法用到模板函数上编译器是不认识的。<br>但是可以用一些模板技巧来实现偏特化的效果，当然本质还是函数的重载。这里用 C++ Concepts 来实现，其实用 SFINAE 也可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认模板函数，返回类型的默认值（默认构造函数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">GetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数相当于 GetValue 对于 bool 的偏特化</span></span><br><span class="line"><span class="comment">// 对于 bool 类型，需要返回 true，而不是其默认值（false）</span></span><br><span class="line"><span class="comment">// 使用 C++ Concepts 添加约束，只有当类型 T == bool 时才实例化这个函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">requires</span> std::same_as&lt;T, <span class="type">bool</span>&gt;  </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串字面量隐式转换成bool"><a href="#字符串字面量隐式转换成bool" class="headerlink" title="字符串字面量隐式转换成bool"></a>字符串字面量隐式转换成bool</h2><p>考虑下面代码所实现的 <code>print</code> 函数，它有两个重载，一个用来打印 bool 值，一个用来打印任意字符串。<br>下面的代码看起来没什么问题，但当 <code>print</code> 函数遇到字符串字面量（string literal）时，编译器会选择调用打印 bool 值的那个重载，而不是打印字符串的那个重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">bool</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; std::boolalpha &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string_view v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; std::format(<span class="string">&quot;\&quot;&#123;&#125;\&quot;&quot;</span>, v) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span>);           <span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);         <span class="comment">// true (not &quot;Hello&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为字符串字面量的本质是个数组（<code>const char[]</code>），编译器首先把它退化成了指针（<code>const char*</code>），然后隐式地将它转换为了 bool 值。</p><p>这个“从指针到 bool”的隐式转换通常用来判断一个指针是否等于 NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>[<span class="number">4</span>])));</span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do sth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要阻止这种隐式转换，可以考虑的一种方案是让打印 bool 值的重载变成模板函数，然后用 C++ concepts 限制它只能接受 bool 值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::same_as&lt;T, <span class="type">bool</span>&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; std::boolalpha &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的重载不需要修改，然后代码就可以正常工作了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实是 C++ 模板的技巧，本文包含两个方面：实现模板函数的“偏特化”的效果，以及阻止字符串字面量隐式转换成 bool。&lt;br&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://uint128.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Modern CMake 实践</title>
    <link href="https://uint128.com/2023/03/06/Modern-CMake-%E5%AE%9E%E8%B7%B5/"/>
    <id>https://uint128.com/2023/03/06/Modern-CMake-%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-03-06T15:23:32.000Z</published>
    <updated>2023-03-10T16:57:51.646Z</updated>
    
    <content type="html"><![CDATA[<p>随着 CMake 版本的迭代变更，使用 CMake 组织项目文件的方法也累积出了很大的变化。考虑到还有不少 CMake 教程停留在一些基础用法，我决定结合我的经验谈谈 CMake 在稍微复杂一些项目上的实践经验。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CMake 其实不止能管理 C++项目，但是这里只讨论用 CMake 管理 <strong>C++ 跨平台项目</strong>的情况。本文所用的 CMake 特性，最低所需的版本是 <strong>CMake 3.20</strong> 版本。阅读本文需要有一定的 CMake 基础。</p><h2 id="如何组织项目结构？"><a href="#如何组织项目结构？" class="headerlink" title="如何组织项目结构？"></a>如何组织项目结构？</h2><p>全凭个人喜好，我目前习惯的结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProjectName/</span><br><span class="line">├── ProjectA/</span><br><span class="line">│   ├── include/</span><br><span class="line">│   ├── src/</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── ProjectB/</span><br><span class="line">│   ├── include/</span><br><span class="line">│   ├── src/</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">├── UnitTest/</span><br><span class="line">│   ├── ProjectA/</span><br><span class="line">│   ├── ProjectB/</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>在书籍《Modern CMake for C++》中推荐的结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Project/</span><br><span class="line">├── cmake/</span><br><span class="line">│   ├── include</span><br><span class="line">│   ├── module</span><br><span class="line">│   └── script</span><br><span class="line">├── src/</span><br><span class="line">│   ├── app1</span><br><span class="line">│   ├── app2</span><br><span class="line">│   ├── lib1</span><br><span class="line">│   └── lib2</span><br><span class="line">├── doc/</span><br><span class="line">├── test/</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure><h2 id="CMakeLists-txt-起手式"><a href="#CMakeLists-txt-起手式" class="headerlink" title="CMakeLists.txt 起手式"></a>CMakeLists.txt 起手式</h2><p>下面三行几乎每个文件都必须有，分别是：设置 CMake 所需最低版本、项目名称和版本（后面 install 部分要用到）、设置 C++ 标准。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(ProjectName VERSION <span class="number">1.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="如何添加源代码？"><a href="#如何添加源代码？" class="headerlink" title="如何添加源代码？"></a>如何添加源代码？</h2><h3 id="视头文件为源代码的一部分"><a href="#视头文件为源代码的一部分" class="headerlink" title="视头文件为源代码的一部分"></a>视头文件为源代码的一部分</h3><p>头文件会在编译前被前处理器载入，简单地粘贴到到引用它的 C++ 源文件中。所以不把头文件加入到 CMake target 的源文件列表中不会影响编译。但是更好的做法是，把头文件也视为源文件的一部分，加入到源文件列表中。</p><p>因为这样做是 “IDE 友好” 的。如果你创建了一个头文件，它没有被任何的源文件引用，也没有被加入到 CMake target 的源文件列表中，我常用的 IDE（CLion）会拒绝对它进行分析，只有基础的语法高亮，而没有编写代码的提示。</p><p>记得仍然要设置 target 的头文件的目录：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(TargetName PUBLIC</span><br><span class="line">        $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">        $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br></pre></td></tr></table></figure></p><h3 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h3><p>优点：简单<br>缺点：IDE 不友好。有新的源文件时必须手动重新建立 CMake 缓存，IDE 不会自动刷新 CMake 缓存。</p><h3 id="简单列出的文件列表"><a href="#简单列出的文件列表" class="headerlink" title="简单列出的文件列表"></a>简单列出的文件列表</h3><p>优点：IDE 友好。添加源文件时必须修改 CMakeLists.txt 文件，IDE 会自动刷新 CMake 缓存。<br>缺点：手动添加每一个文件比较繁琐，但是如果通过 IDE（Visual Studio、CLion）添加头文件或源文件，有自动修改 CMakeLists.txt 源文件列表的功能。</p><h3 id="更复杂的文件列表"><a href="#更复杂的文件列表" class="headerlink" title="更复杂的文件列表"></a>更复杂的文件列表</h3><blockquote><p>印象中见过，但博主还没用过，学会了再给大伙总结下优缺点。</p></blockquote><h2 id="如何创建库项目？"><a href="#如何创建库项目？" class="headerlink" title="如何创建库项目？"></a>如何创建库项目？</h2><p>这一节简要解释两个常见的问题：如何创建跨平台动态库？以及如何让自己的库可以被 “CMake install”，然后被 CMake 中的 “find_package” 找到。</p><h3 id="静态链接库与动态链接库"><a href="#静态链接库与动态链接库" class="headerlink" title="静态链接库与动态链接库"></a>静态链接库与动态链接库</h3><p>在 CMake 中创建静态链接库或是动态链接库，仅仅是 <code>add_library</code> 命令的第二个参数有区别。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(lib_name STATIC lib.h lib.cpp) <span class="comment"># 静态链接库</span></span><br><span class="line"><span class="keyword">add_library</span>(lib_name SHARED lib.h lib.cpp) <span class="comment"># 动态链接库</span></span><br></pre></td></tr></table></figure><p>决定使用动态链接库或静态链接库的因素有很多，比如使用动态链接库可以做到按需加载、替换自身达到功能升级等。甚至在链接开源程序时，考虑使用动态链接可以避免被开源许可证污染。使用静态链接也有一些好处，比如编译产物有更小的体积，或得到单文件程序。</p><p>我个人推荐的做法是，把决定权交给库的使用者，让他来决定编译成静态链接库还是动态链接库。这可以用下面的代码做到：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(LibName_BUILD_SHARED_LIBS <span class="string">&quot;Build LibName as a shared library.&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">if</span> (LibName_BUILD_SHARED_LIBS)</span><br><span class="line">    <span class="keyword">set</span>(LIBRARY_TYPE SHARED)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">set</span>(LIBRARY_TYPE STATIC)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(SOURCE a.hpp a.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(LibName <span class="variable">$&#123;LIBRARY_TYPE&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码首先是创建了一个 Boolean 选项，默认值为 OFF，用来控制是否编译成动态链接库。</p><p>如果编译为动态库，则变量 <code>$&#123;LIBRARY_TYPE&#125;</code> 为 <code>SHARED</code>，否则为 <code>STATIC</code>。这样，库的使用者就可以在生成 CMake 缓存时决定要将这个库编译成什么。</p><p>另外，在编译成动态库时，还做了一步就是将 <code>CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS</code> 设置为 <code>On</code>。设置这个之后，在编译 Windows 平台的动态链接库，会默认导出所有的符号（除了全局变量）。下面会有更多的解释。</p><p>最后，为了做到 “IDE友好”，我建议将源文件列表单独放到一个变量中，即 <code>$&#123;SOURCES&#125;</code>。如果不这么做，CLion 会把 <code>$&#123;LIBRARY_TYPE&#125;</code> 误认为是源文件列表。每次通过 CLion 添加源文件时，CLion 都会想要把新的源文件添加到变量 <code>$&#123;LIBRARY_TYPE&#125;</code> 末尾。 （Visual Studio 暂未做测试）</p><p>GCC 编译的动态链接库，默认是导出所有符号的。而 MSVC 编译的动态链接库，默认是不导出任何符号的。</p><blockquote><p>说实话这一块知识我没具体探究过，比如是否 MinGW 的 g++ 编译器也不需要指定要导出的符号？挖坑以后再研究…</p></blockquote><p>因此在使用 MSVC 编译动态链接库时，需要在代码中使用 <code>__declspec(dllexport)</code> 指定要导出的符号：全局变量或常量、函数、类。而如果要使用 DLL 中符号，则需要在符号的声明中指定 <code>__declspec(dllimport)</code>。具体规则可以见微软的文档，<a href="https://learn.microsoft.com/en-us/cpp/cpp/general-rules-and-limitations?view=msvc-170">General Rules and Limitations</a></p><p>一般来说会定义一个宏，在编译动态库时标记为 <code>__declspec(dllexport)</code>，而在使用动态库时标记为 <code>__declspec(dllimport)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LibName_STATICLIB)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> EXPORTED</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_WIN32) </span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span> defined(LibName_WIN_EXPORT)</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> EXPORTED  __declspec( dllexport )</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> EXPORTED  __declspec( dllimport )</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> EXPORTED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在<strong>编译</strong>动态链接库时，定义宏 <code>LibName_WIN_EXPORT</code>。在<strong>使用</strong>静态链接库时，定义宏 <code>LibName_STATICLIB</code>。在<strong>使用</strong>动态库时，则什么也不定义。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(TargetName PRIVATE LibName_WIN_EXPORT) <span class="comment"># 编译动态链接库时添加该行</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(TargetName PRIVATE LibName_STATICLIB) <span class="comment"># 使用静态链接库时添加该行</span></span><br></pre></td></tr></table></figure><p>对于要导出的符号，使用宏 <code>EXPORTED</code> 修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EXPORTED</span> Utility</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上文提到，CMake 提供了一个变量 <code>CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS</code>，当它为 <code>On</code> 时，会导出所有的符号（除了全局变量）。我推荐用这个方法，因为用了它之后，就不需要给每一个要导出的符号指定 <code>__declspec(dllexport)</code> 和 <code>__declspec(dllimport)</code> 了。</p><h3 id="让你的库能被-find-package-找到"><a href="#让你的库能被-find-package-找到" class="headerlink" title="让你的库能被 find_package 找到"></a>让你的库能被 find_package 找到</h3><h4 id="find-package-做了什么？"><a href="#find-package-做了什么？" class="headerlink" title="find_package 做了什么？"></a>find_package 做了什么？</h4><p>CMake 中的 find_package 有两种模式：Module 模式和 Config 模式。下面只是简要介绍，建议大家阅读 CMake 的<a href="https://cmake.org/cmake/help/latest/command/find_package.html">详细文档</a>。</p><p>在 Module 模式下，CMake 会在 <code>CMAKE_MODULE_PATH</code> 中寻找 <code>Find&lt;PackageName&gt;.cmake</code> 文件。这个 <code>cmake</code> 文件负责寻找 package 的安装路径并检查版本是否符合要求。</p><p>Module 模式并不常用，一般都使用 Config 模式。比如下面这段很常见的代码，CONFIG 指的就是 Config 模式。REQUIRED 表示这个库是必须的，如果没找到这个库就中止 CMake 脚本的运行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PackageName CONFIG REQUIRED)</span><br></pre></td></tr></table></figure><p>在 Config 模式下，CMake 会去寻找 <code>&lt;lowercasePackageName&gt;-config.cmake</code> 或 <code>&lt;PackageName&gt;Config.cmake</code> 文件（下面简称 <strong>config.cmake</strong>）。如果指定了版本号，还会去寻找 <code>&lt;lowercasePackageName&gt;-config-version.cmake</code> 或 <code>&lt;PackageName&gt;ConfigVersion.cmake</code> 文件（下面简称 <strong>version.cmake</strong>）。</p><p>通过指定缓存变量 <code>&lt;PackageName&gt;_DIR</code> 的值，来告诉 CMake 应该去哪里寻找 config.cmake 和 version.cmake 这两个文件。</p><p>这两个文件通常和库的安装目录放在一起。而且它们通常不是库作者自己写的，而是通过一系列 CMake 脚本自动生成的。</p><h4 id="使用-install-指令"><a href="#使用-install-指令" class="headerlink" title="使用 install 指令"></a>使用 install 指令</h4><p>要让自己的库能被别人使用 find_package 指令找到，必须要生成 config.cmake 文件和 version.cmake 文件。除此之外，还要复制编译产物、头文件目录等。</p><p>下面两段代码来自我自己的一个项目 <a href="https://github.com/cyanray/Truss/blob/main/LibTrussSolver/CMakeLists.txt">Truss</a>。先贴出来看看，有个整体的概念，再做进一步分解。</p><p>下面的代码中涉及到两个项目：LibTrussSolver 依赖 LibTrussDocument，因为 LibTrussDocument 项目是在上一级目录中通过 <code>add_subdirectory</code> 找到的，所以要一起被 install。另外 LibTrussSolver 依赖第三方库 Eigen，LibTrussDocument 依赖第三方库 magic_enum。</p><p>下面的代码可以作为模板使用，只需要把项目名称替换成自己的就可以用了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">option</span>(LibTrussSolver_INSTALL <span class="string">&quot;INSTALL_LibTrussSolver&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span> (LibTrussSolver_INSTALL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br><span class="line">    write_basic_package_version_file(</span><br><span class="line">            LibTrussSolverConfigVersion.cmake</span><br><span class="line">            VERSION <span class="variable">$&#123;PACKAGE_VERSION&#125;</span></span><br><span class="line">            COMPATIBILITY AnyNewerVersion</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">install</span>(DIRECTORY <span class="keyword">include</span></span><br><span class="line">            DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">install</span>(TARGETS LibTrussSolver LibTrussDocument <span class="comment"># 两个项目要一起被导出，因为 LibTrussSolver 依赖 LibTrussDocument。</span></span><br><span class="line">            <span class="keyword">EXPORT</span> LibTrussSolverTargets</span><br><span class="line">            RUNTIME DESTINATION bin</span><br><span class="line">            ARCHIVE DESTINATION lib</span><br><span class="line">            LIBRARY DESTINATION lib</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">install</span>(<span class="keyword">EXPORT</span> LibTrussSolverTargets</span><br><span class="line">            <span class="keyword">FILE</span> LibTrussSolverTargets.cmake</span><br><span class="line">            NAMESPACE Truss::</span><br><span class="line">            DESTINATION cmake/LibTrussSolver</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">configure_file</span>(LibTrussSolverConfig.cmake.in LibTrussSolverConfig.cmake @ONLY)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/LibTrussSolverConfig.cmake&quot;</span></span><br><span class="line">            <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/LibTrussSolverConfigVersion.cmake&quot;</span></span><br><span class="line">            DESTINATION cmake/LibTrussSolver</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span> (LibTrussSolver_INSTALL)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LibTrussSolverConfig.cmake.in</span></span><br><span class="line"><span class="keyword">include</span>(CMakeFindDependencyMacro)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被导出的项目的所有依赖都要写在这里</span></span><br><span class="line">find_dependency(magic_enum REQUIRED) <span class="comment"># LibTrussDocument 的依赖</span></span><br><span class="line">find_dependency(Eigen3 REQUIRED)     <span class="comment"># LibTrussSolver 的依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">TARGET</span> LibTrussSolver)</span><br><span class="line">  <span class="keyword">include</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/LibTrussSolverTargets.cmake&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>write_basic_package_version_file</code> 和 <code>configure_file</code> 的作用分别是创建 version.cmake 文件和 config.cmake 文件。</p><p>在 <code>write_basic_package_version_file</code> 中，<code>COMPATIBILITY AnyNewerVersion</code> 指的是，如果版本号比指定的版本号新，那么就认为是兼容的。还有其他的兼容模式可以选择，比如主版本号一致才认为是兼容的，具体见 CMake 的<a href="https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html">文档</a>。</p><p><code>configure_file</code> 指令的作用是将 <code>LibTrussSolverConfig.cmake.in</code> 文件复制为 <code>LibTrussSolverConfig.cmake</code>。（该指令会在复制过程中进行了一些变量替换的处理，但是这个特性在我们的例子中没有用到）</p><p>而在文件 <code>LibTrussSolverConfig.cmake.in</code> 中，指定了两个依赖（根据自己项目的实际情况进行修改，可能更多依赖，也可以能没有依赖），并且包含了 LibTrussSolverTargets.cmake 文件（下面简称 targets.cmake）。</p><p>这个 targets.cmake 文件是由 <code>install(TARGETS)</code> 和 <code>install(EXPORT)</code> 两个指令生成的。</p><blockquote><p>突然发现我对这两个命令的细节并不那么了解，还需要学习一下，再完善这部分。</p></blockquote><p>至于 <code>install(DIRECTORY)</code> 和 <code>install(FILES)</code> 的作用则是复制 <strong>头文件目录</strong> 和 <strong>config.cmake, version.cmake</strong> 到安装目标路径。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="设置编译器参数"><a href="#设置编译器参数" class="headerlink" title="设置编译器参数"></a>设置编译器参数</h3><p>通常跨平台项目的源代码都是 utf-8 编码（因为这是 Linux 系统的默认系统编码）。但是，MSVC 编译器对 utf-8 编码的源文件支持不好，需要额外为 MSVC 编译器设置 <code>/utf-8</code> 参数才能正常编译 utf-8 编码的源文件，否则会出现很多编译错误。</p><p>我常使用下面两行代码为 MSVC 编译器添加 <code>/utf-8</code> 参数。这两行代码用到了 <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html">CMake Generator Expressions</a>。</p><p>如果编译器是 MSVC，那么这个表达式的值就是 <code>/utf-8</code>，CMake 会添加它作为编译参数。如果编译器不是 MSVC，那么这个表达式的值是空文本，<code>add_compile_options</code> 遇到空文本是不会起作用的。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="设置-C-标准"><a href="#设置-C-标准" class="headerlink" title="设置 C++ 标准"></a>设置 C++ 标准</h3><p>通过设置 <a href="https://cmake.org/cmake/help/latest/prop_tgt/CXX_STANDARD.html">CMAKE_CXX_STANDARD</a> 变量的值来要求编译采用指定的 C++ 标准：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>) # 其他取值：<span class="number">98</span>、<span class="number">11</span>、<span class="number">14</span>、<span class="number">17</span>、<span class="number">20</span>、<span class="number">23</span></span><br></pre></td></tr></table></figure></p><p>上面那个是全局设置，下面的指令可以针对某个 target 来设置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> &lt;<span class="keyword">target</span>&gt; PROPERTY CXX_STANDARD &lt;standard&gt;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 CMake 组织项目结构时，不应局限于让项目正常编译，还要考虑到和 IDE 的适配效果，即所谓的 “IDE 友好”。不友好的 CMake 脚本可能会阻碍 IDE 智能感知代码的能力（比如智能提示、查找函数或变量的引用、重构功能等）。</p><p>写一半发现，我还需要再学习一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着 CMake 版本的迭代变更，使用 CMake 组织项目文件的方法也累积出了很大的变化。考虑到还有不少 CMake 教程停留在一些基础用法，我决定结合我的经验谈谈 CMake 在稍微复杂一些项目上的实践经验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://uint128.com/tags/C/"/>
    
    <category term="CMake" scheme="https://uint128.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>牛顿插值法的 Matlab 实现</title>
    <link href="https://uint128.com/2023/01/08/%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://uint128.com/2023/01/08/%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-01-07T18:40:09.000Z</published>
    <updated>2023-01-08T13:14:21.945Z</updated>
    
    <content type="html"><![CDATA[<p>意外的发现了卷积可以用来求多项式相乘的系数。<br><span id="more"></span></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>在学插值之前就已经在 Matlab 上用过多项式插值了，也就是 <code>polyfit</code> 和 <code>polyval</code>。所以在实现牛顿插值的时候，我就希望我的实现在用法上要和 <code>polyfit</code> 的用法是相似的。</p><p>函数 <code>polyfit</code> 的作用是返回多项式的系数，而函数 <code>polyval</code> 是根据多项式的系数，得到一系列点对应的多项式值。那么我的 <code>Interpolation_Newton</code> 也应该返回多项式的系数。</p><p>然后我就遇到了问题，我需要把含有商差的多项式转化为标准的多项式，这就需要做多项式乘法，但我不知道如何高效地实现（其实是懒得写这个程序）。查了别人关于牛顿插值的实现代码，发现有不少实现都用到了卷积计算(<code>conv</code>)。最后我在 MathWorks 的<a href="https://ww2.mathworks.cn/help/matlab/ref/conv.html">文档页面</a>得到了我想要的东西：</p><blockquote><p><code>w = conv(u,v)</code> 返回向量 u 和 v 的卷积。如果 u 和 v 是多项式系数的向量，对其卷积与将这两个多项式相乘等效。</p></blockquote><p>之前也看过一些关于卷积的科普，但好像都没提到卷积还和多项式相乘有关系。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>最后写出来就是这样：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% INIT</span></span><br><span class="line"><span class="comment">% 《数值分析方法与应用》张宏伟、孟兆良编著；大连理工大学出版社</span></span><br><span class="line"><span class="comment">% 第 217 页：四、插值与逼近 第 5 题</span></span><br><span class="line">clear;clc;</span><br><span class="line">format short;</span><br><span class="line"><span class="comment">%% 初始化参数</span></span><br><span class="line"><span class="comment">% 区间</span></span><br><span class="line">range = [<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 函数定义</span></span><br><span class="line">func = @(x) <span class="built_in">sin</span>(<span class="built_in">pi</span> .* x);</span><br><span class="line"><span class="comment">%% 计算与输出</span></span><br><span class="line"><span class="comment">% 已知数据</span></span><br><span class="line">xx = range(<span class="number">1</span>):<span class="number">0.1</span>:range(<span class="number">2</span>);</span><br><span class="line">yy = func(xx);</span><br><span class="line"><span class="comment">% 插值数据</span></span><br><span class="line">p = Interpolation_Newton(xx, yy);</span><br><span class="line">xx1 = range(<span class="number">1</span>):<span class="number">0.05</span>:range(<span class="number">2</span>);</span><br><span class="line">yy1 = polyval(p,xx1);</span><br><span class="line"><span class="comment">% 原函数</span></span><br><span class="line">x = range(<span class="number">1</span>):<span class="number">0.01</span>:range(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,func(x));   <span class="built_in">hold</span> on;</span><br><span class="line"><span class="comment">% 插值点图像</span></span><br><span class="line"><span class="built_in">plot</span>(xx1,yy1,<span class="string">&#x27;--o&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;原函数&#x27;</span>, <span class="string">&#x27;插值&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factors</span> =  <span class="title">Interpolation_Newton</span><span class="params">(x, y)</span></span></span><br><span class="line">    n = <span class="built_in">length</span>(x);</span><br><span class="line">    dd = <span class="built_in">zeros</span>(n,n);</span><br><span class="line">    <span class="comment">% 计算均差</span></span><br><span class="line">    dd(<span class="number">1</span>,:) = y;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> r = <span class="number">1</span>:n-k</span><br><span class="line">            dd(k+<span class="number">1</span>, r) = ( dd(k, r+<span class="number">1</span>) - dd(k, r) ) / (x(r+k)-x(r));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 计算各阶多项式系数</span></span><br><span class="line">    p = <span class="built_in">zeros</span>(n,n);</span><br><span class="line">    p(<span class="number">1</span>,<span class="keyword">end</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">2</span>:n</span><br><span class="line">        <span class="comment">% conv (卷积计算):</span></span><br><span class="line">        <span class="comment">% 对两个多项式系数进行卷积计算可得到多项式相乘的系数</span></span><br><span class="line">        p(k,:) = conv(p(k<span class="number">-1</span>,<span class="number">2</span>:<span class="keyword">end</span>), [<span class="number">1</span>, -x(k<span class="number">-1</span>)]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    factors = sum(dd(:,<span class="number">1</span>) .* p);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;意外的发现了卷积可以用来求多项式相乘的系数。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>多元牛顿迭代法的 Matlab 实现</title>
    <link href="https://uint128.com/2023/01/08/%E5%A4%9A%E5%85%83%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://uint128.com/2023/01/08/%E5%A4%9A%E5%85%83%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-01-07T18:38:42.000Z</published>
    <updated>2023-01-08T12:28:13.215Z</updated>
    
    <content type="html"><![CDATA[<p>这学期的《最优化方法》课和《矩阵与数值分析》课都用到了牛顿迭代法，在《优化》里需要多元函数的牛顿迭代法，在《矩阵》里只用到一元函数的牛顿迭代法。<br><span id="more"></span></p><script type="math/tex; mode=display">    x^{(k+1)} = x^{(k)} - \frac{f(x)}{f'(x)}    \tag{1}    \label{1}</script><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>这两门课程的上机作业都需要自己编写一个牛顿迭代法的程序，我希望这个牛顿迭代法的实现要能同时用于求解多元函数问题和一元函数问题，还要能指定初始迭代点、目标精度和最大迭代次数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后写出来就这样：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[fval, xval, precision, iteration]</span> = <span class="title">Newton</span><span class="params">(...</span></span></span><br><span class="line"><span class="params"><span class="function">    calc_fval, calc_grad, initial_point, target_precision, max_iteration)</span></span></span><br><span class="line"><span class="comment">%% 牛顿迭代法(一元或多元函数)</span></span><br><span class="line"><span class="comment">% INPUT:</span></span><br><span class="line"><span class="comment">% calc_fval (function_handle): 计算目标函数值的函数句柄</span></span><br><span class="line"><span class="comment">% calc_gard (function_handle): 计算目标函数梯度的函数句柄</span></span><br><span class="line"><span class="comment">% initial_point (vector): 初始迭代点</span></span><br><span class="line"><span class="comment">% target_precision (scalar): 目标精度</span></span><br><span class="line"><span class="comment">% max_iteration (scalar): 最大迭代次数</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% OUTPUT:</span></span><br><span class="line"><span class="comment">% fval (scalar): 函数值</span></span><br><span class="line"><span class="comment">% xval (vector): 迭代值</span></span><br><span class="line"><span class="comment">% precision (scalar): 精度</span></span><br><span class="line"><span class="comment">% iteration (scalar): 迭代次数</span></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">N = <span class="number">0</span>;                          <span class="comment">% 迭代次数</span></span><br><span class="line">xval = initial_point;           <span class="comment">% 迭代解</span></span><br><span class="line">precision = <span class="built_in">inf</span>;</span><br><span class="line"><span class="keyword">while</span> precision &gt;= target_precision</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= max_iteration); <span class="keyword">break</span>; <span class="keyword">end</span></span><br><span class="line">    N = N + <span class="number">1</span>;</span><br><span class="line">    fval = calc_fval(xval);</span><br><span class="line">    grad = calc_grad(xval);</span><br><span class="line">    d = grad \ fval;</span><br><span class="line">    xval = xval - d;</span><br><span class="line">    precision = norm(d);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">iteration = N;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这学期的《最优化方法》课和《矩阵与数值分析》课都用到了牛顿迭代法，在《优化》里需要多元函数的牛顿迭代法，在《矩阵》里只用到一元函数的牛顿迭代法。&lt;br&gt;</summary>
    
    
    
    
    <category term="Matlab" scheme="https://uint128.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>我的 2022 总结</title>
    <link href="https://uint128.com/2022/12/31/%E6%88%91%E7%9A%84-2022-%E6%80%BB%E7%BB%93/"/>
    <id>https://uint128.com/2022/12/31/%E6%88%91%E7%9A%84-2022-%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-31T15:39:22.000Z</published>
    <updated>2022-12-31T16:40:14.041Z</updated>
    
    <content type="html"><![CDATA[<p>不知道从哪里开始总结，好像也没什么可以总结的。<br><span id="more"></span></p><p>上半年忙于毕设，几乎每天都投入其中，最后顺利毕业！</p><p>然后是暑假，因为疫情也没去哪里玩。看了几本书想把 C++20 Coroutine 研究明白，拖拖拉拉也没什么进展。写了几篇博文，因为懒又没写完，现在还只剩个框架在那里。</p><p>暑假之后就是研究生开学了，研一课程多，每天不是在上课就是在写作业。不过这学期学的《最优化理论》和《矩阵分析与数值计算》这两门课程挺有用的，感觉可以写一篇文章分享下我的上机作业代码。</p><p>看了下我 2022 年的 GitHub 的记录，commit 数量比 2021 年少得多。这不是我在偷懒，确实是没什么代码可写的。我不想总是去写那些我会的东西，增删改查、适配个 SDK 或者逆向分析 APP 写爬虫什么的，写多了有些枯燥了。</p><p>今年其实学了不少新东西的，只是新东西太多太难了，不是三两天能学会，然后马上就能写出什么好作品。</p><p>到了明年，2023 年，应该就不一样了。我还会花很多时间去写代码，不过写的东西肯定都和以前不一样了。</p><p>我会继续我 2022 年没完成的想法。比如继续了解 C++20 Coroutine，或许可以试着写一个协程库；了解一下并行编程，比如 OpenMP 或者 CUDA，或许我可以把一些线性代数的算法改写成并行的实现。然后是新东西，比如说这学期学了有限元分析，我觉得我可以写一个玩具有限元求解器（已经在做了）；再了解下机器学习方面的东西，没时间就算了。</p><p>关于 2023 年的展望。</p><p>下学期不封校，把学校附近的美食都吃一遍。</p><p>拍很多好看的照片。</p><p>找到我喜欢做的事情，投入其中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道从哪里开始总结，好像也没什么可以总结的。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CPU并发编程学习小结</title>
    <link href="https://uint128.com/2022/08/22/CPU%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>https://uint128.com/2022/08/22/CPU%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</id>
    <published>2022-08-22T15:56:53.000Z</published>
    <updated>2023-07-14T16:47:03.390Z</updated>
    
    <content type="html"><![CDATA[<p>在之前接触 C++ Coroutine 的时候，看到了开源代码中关于内存序(memory order)的使用，于是想要了解一下这个内存序到底是个什么东西。结果发现相关的知识体系非常庞大，想要真正搞懂内存序是怎么来的、有什么用和什么时候用，需要搞清楚的东西根本不是一两天能学会的。本来只是想了解下内存序是什么，结果一不小心从《计算机体系结构》、《操作系统导论》一路学到了并发编程……</p><span id="more"></span><p>这篇文章梳理一下我在探索“内存序是个什么东西”时，学到的与 CPU 并发编程相关的知识，把我以前粗略了解的很多概念全部串起来了。</p><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p>并发与并行这两个概念很相似，但其实是有区别的。<strong>并行</strong>的两个任务在<strong>某个时间点</strong>同时运行，而<strong>并发</strong>则是在<strong>某一段时间内</strong>同时运行，在这段时间里两个任务可能是交替进行的。</p><p>结合一些例子说明会更好理解：一边打游戏一边喝可乐，如果暂停游戏拿起可乐喝一口再继续游戏，这就是并发；如果打游戏的同时用吸管喝可乐，这就是并行。</p><p>并发在一段时间内造成了同时进行多项任务的假象，而并行是真正的同时进行多项任务。</p><h2 id="CPU-的并行技术"><a href="#CPU-的并行技术" class="headerlink" title="CPU 的并行技术"></a>CPU 的并行技术</h2><p>通常在讨论并发和并行的时候，都是在讨论多线程编程。其实在 CPU 内部也有一些并行技术，它们旨在提高 CPU 性能。在 CPU 设计里，提升 CPU 并行性的方法有两类：一类是允许 CPU 同时执行多条指令的<strong>指令级并行</strong>技术；另一类是运行 CPU 同时执行多个任务的<strong>线程级并行</strong>技术。</p><h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p><strong>指令流水线</strong>技术可以让 CPU 同时执行多条指令，实现指令级并行。下面简单地说明他的原理，要详细地了解它可以参考《计算机组成与设计：硬件/软件接口》这本书。</p><p>对于 MIPS 指令集的 CPU 来说，一条指令的执行可以分为五个步骤：读取指令、指令解码与读取寄存器、执行指令、存储器访问和写回寄存器；</p><p>MIPS 指令的格式使得它可以同时进行指令解码与读取寄存器的值。对于其他指令集的处理器，可能不止五个步骤。</p><p>在没有流水线的处理器上，上一条指令的这五个步骤要全部执行完，才可以执行下一条指令。在处理器进行<strong>指令解码和读取寄存器</strong>这个步骤时，<strong>读取指令</strong>等其他部分的电路是闲置着的。流水线技术就是让其他部分的电路也运转起来，用来执行其他的指令。</p><p>用《计算机组成与设计：硬件/软件接口》里的例子来说明，这本书用洗衣服的过程来类比 CPU 的运行过程。洗衣店的工作流程可以分为：洗衣服、烘干衣服、叠衣服和收衣服四个步骤。在烘干衣服的时候，洗衣机、叠衣服的桌子和收衣服的人都是空闲的。如果采用流水线技术，此时可以让洗衣机去洗下一批衣服，等烘干机的工作结束，把衣服放到桌子上去叠衣服，而下一批的衣服也洗好了，正好可以放到烘干机里……</p><p>下面这张图展示了指令流水线的工作情况，在同一个 CPU 时钟周期里有多条指令同时执行。</p><p><img src="指令流水线示意图.png" alt="指令流水线示意图"></p><p>流水线可能会遇到在下一个时钟周期里下一条指令不能执行的情况，这种情况称为<strong>冒险</strong>（hazard）。流水线冒险有很多种情况，比如跳转指令会导致控制冒险。因为在跳转的条件计算出来之前，CPU 无法确定要继续执行哪里的指令，通常的解决方法是<strong>分支预测</strong>，让 CPU 猜一个分支继续执行。如何解决流水线冒险不是本文的主题因此不继续展开。</p><p>另一种指令级并行的技术是<strong>多发射（multi-issue）</strong>，意思是按顺序地一次获取多条指令并同时执行。实现了这种指令级并行的处理器称为<strong>超标量处理器（superscalar processor）</strong>，标量处理器每个时钟周期最多可以<strong>完成</strong>一条指令，而超标量处理器一个时钟周期可以完成多条指令（IPC &gt; 1）。</p><p>执行单元（Execution units, EUs）是 CPU 中用于执行算数逻辑计算、分支和其他操作的独立模块。执行单元一般包括：算术逻辑单元（ALU）、浮点单元（FPU）、地址生成单元（AGU）等。</p><p>多发射是通过让 CPU 拥有多个执行单元实现的，将多条指令分配到不同的执行单元，这样指令就可以被同时执行。</p><p>这个技术的实现细节是很复杂的，因为并行执行的多条指令之间不可以有数据依赖。编译器在编译阶段可以分析指令间的数据依赖，通过调整指令的顺序以解决数据依赖问题，而且不会影响程序的执行结果。CPU 在运行阶段也可以检查指令间的数据依赖，通过动态调整指令的执行顺序来解决数据依赖问题，这让 CPU 拥有了<strong>乱序执行（out-of-order execution）</strong>的特性。</p><h3 id="线程级并行"><a href="#线程级并行" class="headerlink" title="线程级并行"></a>线程级并行</h3><p><strong>同时多线程（Simultaneous multithreading, SMT）</strong>技术可以在单个 CPU 内核上运行多个任务。SMT 名字里的“线程”不一定是同一个进程的线程，可以是两个不同进程的线程。在 Intel CPU 里，它被称为超线程技术（Hyper-Threading, HT），就是那个让一个处理器核心变两个处理器核心的技术。</p><p>同时多线程的原理是把闲置的执行单元利用起来，只需要增加一些寄存器和其他部件来保存机器状态，就可以提升 CPU 的并行性能。</p><h2 id="操作系统的多任务"><a href="#操作系统的多任务" class="headerlink" title="操作系统的多任务"></a>操作系统的多任务</h2><p>计算机的资源（CPU 资源、内存资源或硬盘资源等）由操作系统进行管理，现代操作系统将计算机的物理资源虚拟化处理，比如 CPU 虚拟化和内存虚拟化，让每个程序都以为自己拥有完整的 CPU 和完整的内存。</p><p>在只有一个核心的 CPU 上，操作系统依然可以做到同时运行多个程序，其中的原理我相信绝大多数读者都了解过。CPU 资源在时间上被划分，让一个程序使用一段时间的 CPU，然后让下一个程序使用一段时间的 CPU，如此下来，CPU 就被几个程序共享了。</p><blockquote><p>如果要深入了解，推荐阅读人民邮电出版社的《操作系统导论》，原著是《Operating Systems: Three Easy Pieces》，书和翻译都很好。</p></blockquote><p>这种暂停当前程序的执行并切换到另一个程序继续执行的操作，称为<strong>上下文切换（Context switch）</strong>。上下文切换要保存当前程序的程序计数器（Program Counter, PC）、CPU 当前所有寄存器的值、和内存虚拟化相关的一些值，以及其他，然后恢复另一个程序的程序计数器、寄存器值、内存虚拟化相关的值等等。</p><p>虽然看起来上下文切换的开销很大，但是除非进程或者线程很多导致上下文切换很频繁，一般来说不用考虑上下文切换的开销。</p><p><strong>多进程</strong>和<strong>多线程</strong>都是实现并发的方法，在可靠性、资源占用、编程难易程度等方面各有优势与不足。</p><p>多进程方案在可靠性上有明显优势，多线程程序任意一条线程的异常都会导致整个程序崩溃。Chrome 浏览器和许多有限元分析软件都采用的多进程方案。</p><h2 id="多处理器调度的问题"><a href="#多处理器调度的问题" class="headerlink" title="多处理器调度的问题"></a>多处理器调度的问题</h2><p>现在的处理器基本都是多核心设计，这其实就意味着计算机实际上是有多个处理器的。对操作系统来说，多处理器的多任务调度（决定何时进行上下文切换的策略）会给程序员带来一些麻烦，下面来讨论这些问题。</p><h3 id="缓存亲和性"><a href="#缓存亲和性" class="headerlink" title="缓存亲和性"></a>缓存亲和性</h3><p>CPU 寄存器的访问速度很快，与之相比内存的访问速度就慢多了。<strong>缓存（Cache）</strong>是介于 CPU 寄存器和内存之间的存储器，容量比内存小很多，访问速度比内存快得多。</p><p>现代处理器的缓存是多级的，一般分为 L1、L2、L3 三个级别，容量依次增加，访问速度依次降低。L1 级缓存又会被拆分成两块，一块专门用来存储指令，另一块专门用来存储数据。下图展示了三级缓存的结构（缓存大小的数值是随便填的）。</p><p><img src="cpu_cache_architecture.png" alt="CPU 缓存架构"></p><p>缓存之所以能够起作用，是因为程序的执行具有局部性特征，局部性有两种：<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p><ul><li><p>时间局部性：当一个数据被访问后，它很快会被再次访问。比如循环变量 <code>i</code> 和循环体的指令本身。</p></li><li><p>空间局部性：当一个数据被访问后，很可能紧接着访问它周围的数据。比如遍历数组和指令的顺序执行。</p></li></ul><p>CPU 在获取数据时会先在 L1 级缓存中寻找，如果没找到，也就是缓存未命中，那么就会到下一级 L2 级缓存寻找，还找不到就从 L3 级缓存寻找，最后从内存中获取数据。</p><p>如果频繁遇到缓存未命中，会严重影响 CPU 的运行速度。在编写程序的时候，要考虑到缓存的影响。比如操作系统的多处理器调度策略，要尽可能地让同一个进程保持在同一个 CPU 上。这是因为一个进程运行一段时间后，缓存中维护着该进程的许多状态。当该进程恢复到上一次运行的 CPU 时，缓存就能起作用。</p><p>又比如遍历二维数组时，按行遍历和按列遍历的速度是不一样的，按行遍历的速度应该会更快些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; MAX_ROW; ++row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> column = <span class="number">0</span>; column &lt; MAX_COLUMN; ++column)</span><br><span class="line">    &#123;</span><br><span class="line">        data[row * MAX_COLUMN + column] = <span class="number">1</span>;    <span class="comment">// 按行遍历，一行一行地遍历</span></span><br><span class="line">        data[column * MAX_ROW + row] = <span class="number">1</span>;       <span class="comment">// 按列遍历，一列一列地遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指针 data 所指向的内存区域足够大，无法全部装进 L1 缓存中，那么这两种遍历方式的差距将会很大。按列访问每次访问的内存区域跨度很大，很可能会遇到缓存未命中的情况，此时 CPU 不得不去下一级缓存甚至内存中寻找数据，这就降低了效率。用“局部性”的概念来理解，按列访问不符合“空间局部性”的特点，因此缓存无法起到加速作用。</p><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>如果有多个处理器，每个处理器有自己的缓存，并且共享同一个内存，那么会出现<strong>缓存一致性（Cache Coherence）</strong>问题。</p><p>假设一个运行在 <strong>CPU 1</strong> 的程序从<strong>内存地址 A</strong>读取数据。由于数据不在 <strong>CPU 1</strong> 的缓存中，所以系统直接访问内存，得到了<strong>值 D</strong>。程序修改了<strong>地址 A</strong> 处的值，这个修改体现在<strong>只是</strong>将它的缓存更新为新的值 <strong>D’</strong>。由于将数据写回内存比较慢，因此系统通常会稍后再进行回写。假设此时操作系统中断了该程序的运行，并在稍后将其交给 <strong>CPU 2</strong> 继续运行，程序重新读取<strong>地址 A</strong> 的数据，由于 <strong>CPU 2</strong> 的缓存中没有该数据，所以又会直接从内存中读取，结果得到了<strong>旧值 D</strong>，而不是正确的<strong>值 D’</strong>。</p><p>硬件提供了这个问题的基本解决方案：监控内存访问。在基于总线的系统中，一种方式是使用总线窥探（Bus Snooping）来发现<strong>内存访问</strong>。如果 CPU 从监听到的内存访问中，发现了对它放在缓存中的数据的更新，那么会根据内存访问，作废（Invalidate）缓存的值，或更新（Update）缓存的值为新的值。</p><p>关于其中的细节，可以从<strong>缓存一致性协议：MESI</strong> 中了解到更多。</p><blockquote><p>这个网站：<a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm">https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm</a> 提供了一个可交互程序来学习 MESI 协议。</p></blockquote><h3 id="内存一致性问题"><a href="#内存一致性问题" class="headerlink" title="内存一致性问题"></a>内存一致性问题</h3><blockquote><p>该内容有待完善。。。</p></blockquote><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>考虑一个简单的例子，给变量 <code>counter</code> 加上数字 1，其生成的 x86 代码可能是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8049a1c, %eax            # 将变量 counter 所在内存的值移入寄存器 %eax</span><br><span class="line">add $0x1, %eax                 # 将寄存器 %eax 的值与数字 1 相加</span><br><span class="line">mov %eax, 0x8049a1c            # 将寄存器 %eax 的值移回变量 counter 所在的内存</span><br></pre></td></tr></table></figure></p><p>现在有多个线程（比如说有 10 条线程），循环执行（比如每条线程循环 1000 次）上面的代码。当所有线程都执行完毕，预期的结果是 <code>counter == 10000</code>。但实际上很可能不是 10000 这个结果，甚至每次运行的结果可能都不一样，可能是 9987 或 9876 或别的什么数字。</p><p>问题出现在<strong>线程的调度</strong>上。暂且考虑只有两条线程同时执行上述代码的情况，并将 <code>counter</code> 的初始值设置为 0。</p><p><strong>第一条线程（Thread A）</strong>刚把 <code>counter</code> 所在内存的值移入寄存器 <code>%eax</code> 中，操作系统就暂停了它的执行，然后让<strong>第二条线程（Thread B）</strong>开始执行。</p><p><strong>Thread B</strong> 也做了同样的事情，把 <code>counter</code> 所在内存的值移入寄存器 <code>%eax</code> 中，将寄存器 <code>%eax</code> 的值与数字 1 相加，最后将寄存器 <code>%eax</code> 的值移回变量 <code>counter</code> 所在的内存。<strong>Thread B</strong> 顺利的执行了完毕了，此时，counter 的值为 1。</p><p>然后，操作系统恢复了 <strong>Thread A</strong> 的执行，但是 <strong>Thread A</strong> 的 <code>%eax</code> 寄存器中储存的仍然是 <code>counter</code> 的旧值 0。<strong>Thread A</strong> 在旧值上加 1，再写回内存，<strong>Thread A</strong> 执行完毕了，但 <code>counter</code> 的值还是 1，错误就这么产生了。</p><p>这里展示的情况称为<strong>竞态条件（Race condition）</strong>：运行结果取决于代码的时间执行。</p><p>执行这段代码的多个线程可能导致竞争状态，因此我们将此段代码称为<strong>临界区（Critical section）</strong>。临界区是访问共享变量（或更一般的说，共享资源）的代码片段，一定不能由多个线程同时执行。</p><p>我们真正想要的代码就是所谓的<strong>互斥（mutual exclusion）</strong>。这个属性保证了如果一个线程在临界区内执行，其他线程将被阻止进入临界区。</p><blockquote><p>这些术语都是由 dijkstra 创造的，他是该领域的先驱。</p></blockquote><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p><strong>原子化(atomic) 操作</strong>：将一系列操作组合在一起，但是只有“全部完成”或“什么都没有发生”两个状态，没有中间状态。这个概念类似于数据库处理中的<strong>事务（transaction）</strong>。</p><p>对于上文中的 <code>counter = counter + 1</code>，如果可以原子化的进行，就不会存在竞态条件了。但存在竞态条件的代码很多，不能指望硬件提供各种各样的原子操作，这难以实现。</p><p>实际上只需要硬件提供一些有用的指令，在这些指令上构建一个通用的集合，即所谓的<strong>同步原语（synchronization primitive）</strong>。通过使用这些硬件同步原语，加上操作系统的一些帮助，就能构建多线程代码，以同步和受控的方式访问临界区，从而可靠地产生正确的结果。</p><h2 id="解决同步问题：互斥锁与条件变量"><a href="#解决同步问题：互斥锁与条件变量" class="headerlink" title="解决同步问题：互斥锁与条件变量"></a>解决同步问题：互斥锁与条件变量</h2><p>考虑将上文提及的关于 <code>counter</code> 自增 1 的临界区代码加上互斥锁，其代码可能如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lock_t</span> mutex;</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">counter = counter + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>互斥锁就是一个变量，如上面代码中的变量 <code>mutex</code>。锁变量保存了锁某一时刻的状态，这个锁要么是可用的（available, unlocked, free），表明没有任何线程持有锁；要么是被占有的（acquired, locked, held），表明有一个线程持有锁，正处于临界区。</p><p>调用函数 <code>lock()</code> 会尝试获取锁，如果没有其他线程占有锁，那么当前线程会获得锁并进入临界区，此时当前线程被称为<strong>锁的持有者(owner)</strong>。如果其他线程正占有锁，那么这个调用不会立刻返回。直到持有锁的线程调用 <code>unlock()</code> 释放锁，这个调用才会返回。</p><blockquote><p>锁为程序员提供了最小程度的调度控制。通过给临界区加锁，可以保证临界区内只有一个线程活跃。锁将原本由操作系统调度的混乱状态变得更为可控。</p></blockquote><h3 id="评价锁"><a href="#评价锁" class="headerlink" title="评价锁"></a>评价锁</h3><p>上面仅仅是介绍了锁的两个基本语义，并未涉及到锁的具体实现。下面罗列一些评估锁实现效果的标准，以便比较各种锁的实现效果。</p><ol><li>锁是有效性。锁能否阻止多个线程进入临界区？</li><li>锁的公平性。当锁可用时，是否每一个竞争线程有公平的机会抢到锁？是否有竞争锁的线程会<strong>饿死(starve)</strong>，一直无法获得锁？</li><li>锁的性能。使用锁之后增加的时间开销。有几种场景需要考虑，一种是没有竞争的情况，即只有一个线程抢锁、释放锁的开支如何？另一种是一个 CPU 上多个线程竞争，性能如何？最后一种是多个 CPU、多个线程竞争时的性能。</li></ol><h3 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h3><p>最早提供的互斥解决方案之一，就是在临界区关闭中断。这个方案只适用于单处理器系统，关闭中断后代码就不可能被打断执行了。</p><p>但这种方案的缺点很多：</p><ol><li>机制容易被滥用。极端的例子：一个恶意程序从运行就获取锁，然后再也不释放，操作系统将失去控制权。</li><li>不支持多处理器。如果多个线程运行在不同的处理器， 那么关闭中断也没用。</li><li>关闭中断导致中断丢失，后果严重。比如错过硬盘设备完成读取请求的中断，操作系统就无法唤醒等待读取的进程。</li><li>效率低下。开启关闭中断的操作执行的较慢。</li></ol><h3 id="Peterson-算法"><a href="#Peterson-算法" class="headerlink" title="Peterson 算法"></a>Peterson 算法</h3><p>Peterson 算法是一种不依赖原子操作（这需要硬件支持）的纯软件实现的锁方案，它只支持两条线程的互斥访问。下面是它的实现代码，注意它无法在松散内存一致性模型上正常工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag[<span class="number">0</span>] = flag[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 1 -&gt; thread wants to grab lock</span></span><br><span class="line">    turn = <span class="number">0</span>;               <span class="comment">// whose turn? (thread 0 or 1?)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag[self] = <span class="number">1</span>;         <span class="comment">// self: thread ID of caller</span></span><br><span class="line">    turn = <span class="number">1</span> - self;        <span class="comment">// make it other thread&#x27;s turn</span></span><br><span class="line">    <span class="keyword">while</span>((flag[<span class="number">1</span> - self] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - self))</span><br><span class="line">        ; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag[self] = <span class="number">0</span>;         <span class="comment">// simply undo your intent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解它的原理，可以先假设两个运行场景，分别进行分析：两条线程严格地按顺序调用 <code>lock()</code> 以及两条线程竞争调用 <code>lock()</code> 的情况。</p><p>如果两条线程严格地按先后顺序分别调用 <code>lock()</code>，即第二条线程在第一条线程调用返回后（获得锁之后）再调用 <code>lock()</code>，在这种情况下进行分析是很容易的。第二条线程会进入自旋循环，直到第一条线程调用 <code>unlock()</code> 后，使得 <code>flag[1 - self] == 1</code> 的条件不再满足，从而跳出自旋，调用返回，进入临界区。这说明该算法实现的锁，竞争的线程不会被饿死。</p><p>如果两条线程竞争地调用 <code>lock()</code>，可以先找出其中的竞态条件，容易发现竞态条件存在于 <code>turn = 1 - self</code>。这导致在两条线程同时调用 <code>lock()</code> 时，变量 <code>turn</code> 的值可能是 <code>self</code> 也可能是 <code>1 - self</code>，即可能是 <code>0</code> 也可能是 <code>1</code>。注意到此时 <code>flag[0] == flag[1] == 1</code> 总是成立，因此自旋循环的第一个条件始终满足。而第二个条件则不一定满足，但至少有一条线程满足，从而进入自旋循环。</p><p>上述粗糙的推理说明该算法实现的锁是有效的，且保证竞争的线程不会被饿死。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在实现锁时，一个简单的想法是：用一个变量(<code>flag</code>)来标志锁是否被占有，如果锁被占有(<code>flag == 1</code>)则自旋等待，直到锁被释放（<code>flag == 0</code>）则跳出自旋，并重新占有锁(<code>flag = 1</code>)。这种简单的想法所实现的锁称为<strong>自旋锁(Spin lock)</strong>。</p><p>代码实现类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="type">int</span> flag; &#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123; </span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>; <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// Test the flag</span></span><br><span class="line">        ; <span class="comment">// spin-wait</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>;        <span class="comment">// acquire lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上述的代码是无法让自旋锁正确工作的。如果让多条线程交替执行，很容易构造出一种调度方案，使得两条线程同时获得锁并进入临界区。想象有 3 条线程，其中一条线程持有锁，并即将释放锁，而另外两条线程正在自旋等待锁。当锁被释放时，如果另外两条正在自旋的线程依次跳出自旋（这样的调度情况显然存在），就会导致有两条线程同时持有锁并进入临界区。</p><p>上述代码无法正确工作的本质原因就是<strong>存在竞态条件</strong>，如果能让“测试锁是否被占有”与“占有锁”这两个步骤原子地进行，消除竞态条件，就能正常工作了。利用硬件提供的同步原语，可以实现这一点。</p><h4 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h4><p>下面的代码展示了 <code>TestAndSet</code> 指令做了什么：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr;     <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = new;         <span class="comment">// store &#x27;new&#x27; into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old;             <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它返回 <code>old_ptr</code> 指向的旧值，同时将其更新为 <code>new</code> 这个新的值，关键的是它们是原子地执行。利用它重新实现自旋锁的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompareAndExchange"><a href="#CompareAndExchange" class="headerlink" title="CompareAndExchange"></a>CompareAndExchange</h4><p><code>CompareAndExchange</code> 指令做的事情类似于下面的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndExchange</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span>(actual == expected)</span><br><span class="line">        *ptr = new;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>比较并交换的基本思路是检测 ptr 指向的值是否和 expected 相等；如果是，更新 ptr 所指的值为新值。否则，什么也不做。不论哪种情况，都返回该内存地址的实际值，让调用者能够知道执行是否成功。</p><p>使用比较并交换实现的 <code>lock()</code> 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Link-Load-amp-Store-Conditional"><a href="#Link-Load-amp-Store-Conditional" class="headerlink" title="Link-Load &amp; Store-Conditional"></a>Link-Load &amp; Store-Conditional</h4><p><strong>链接的加载（load-linked）</strong>和<strong>条件式存储（store-conditional）</strong>的配合使用也可以实现锁。</p><p>链接的加载和典型的加载指令类似，都是从内存中取出值存入一个寄存器。</p><p>条件式存储指令只有在上一次加载的地址没有更新时，才会成功。成功时，条件存储返回 1，并更新值。失败时，返回0，并且不会更新值。</p><p>用这两条指令实现的 <code>lcok()</code> 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(LoadLinked(&amp;lock-&gt;flag) || !StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>)) <span class="comment">// 注意条件短路</span></span><br><span class="line">        ; <span class="comment">//spin-wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="评价自旋锁"><a href="#评价自旋锁" class="headerlink" title="评价自旋锁"></a>评价自旋锁</h4><p>现在按照之前罗列的标准来评价自旋锁。</p><p>首先，正确性。毫无疑问，自旋锁是正确的锁。</p><p>然后，公平性。自旋锁不提供任何公平性保证，可能导致饿死。比如三条线程竞争锁，其中两条线程轮番获得锁，而另一条线程永远在自旋。</p><p>最后，性能。在单 CPU 的情况下，自旋锁性能开销相当大。假设一条线程持有锁，调度器运行其他的每一个线程时，它们都在自旋，使得任务没有任何进展。在多 CPU 上，如果线程数大致等于 CPU 数，性能表现不错。</p><h3 id="Ticket锁"><a href="#Ticket锁" class="headerlink" title="Ticket锁"></a>Ticket锁</h3><p>Ticket 锁是使用硬件原语 <code>FetchAndAdd</code> 指令实现的。<code>FetchAndAdd</code> 能原子地返回特定地址的旧值，并且让该值自增一。</p><p>Ticket 锁的代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ticket;</span><br><span class="line">    <span class="type">int</span> turn;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;turn != myturn)</span><br><span class="line">        ; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不同于自旋锁，Ticket 锁保证所有线程都能抢到锁，只要一个线程获得了 Ticket 值，它最终会被调度。</p><h3 id="解决自旋太多"><a href="#解决自旋太多" class="headerlink" title="解决自旋太多"></a>解决自旋太多</h3><p>不必要的自旋是在浪费 CPU 时间，有两种避免自旋的方法：</p><ol><li>让出时间片。<strong>yield</strong> 原语可以让线程主动放弃 CPU，让其他线程进行。</li><li>休眠代替自旋。维护一个队列，如果锁不可用，则休眠并加入队列；当锁的持有者释放锁时，从队列中恢复一条线程的执行。</li></ol><p>让出时间片的方案虽然避免了自旋，但是上下文切换的开销没法避免，而且也没能避免饿死的情况。</p><p>以休眠代替自旋的方案则没有这两个问题，但是具体实现上需要小心竞态条件。</p><blockquote><p>更多细节阅读 《操作系统导论》 Section 28.14。</p></blockquote><h3 id="二阶段锁"><a href="#二阶段锁" class="headerlink" title="二阶段锁"></a>二阶段锁</h3><p><strong>两阶段锁（Two-phase lock）</strong>意识到自旋可能很有用，尤其是在很快就要释放锁的场景。因此，两阶段锁的第一阶段会先自旋一段时间，希望它可以获取锁。但是，如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><blockquote><p>该部分内容有待完善…</p></blockquote><h2 id="使用互斥锁导致的问题"><a href="#使用互斥锁导致的问题" class="headerlink" title="使用互斥锁导致的问题"></a>使用互斥锁导致的问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁(Deadlock)</strong>是类似这样一种情况：</p><ol><li>有 2 个线程同时执行，并且都需要访问<em>共享资源 A</em> 以及<em>共享资源 B</em>；</li><li><em>线程 1</em> 获得了共享资源 A 的锁，线程 2 获得了共享资源B的锁；</li><li><em>线程 1</em> 尝试获得<em>共享资源 B</em> 的锁，但是因为这个锁已经被<em>线程 2</em> 占有，因此它失败了，进入休眠状态；</li><li>类似的，<em>线程 2</em> 尝试获得<em>共享资源 A</em> 的锁，因为锁已经被<em>线程 1</em> 占有，因此也休眠了；</li></ol><p>最后，两条线程都进入了休眠状态，系统的执行不再有进展，形成了死锁。</p><p>我在查阅资料时，注意到了形成死锁的四个条件（禁止抢占、持有和等待、互斥、循环等待），因此避免死锁的方法就是破坏这四个条件之一。</p><p>但我感觉根据那四个条件来解决死锁等于没说。我认为比较合适的预防死锁的方式是：当需要获得多个资源的锁时，获取锁的顺序应当保证全局一致。</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p><strong>活锁(Livelock)</strong>与死锁类似，处于活锁状态的系统虽然有任务在执行，但是依然没有任何推进。以下是一个可能导致活锁的情况：</p><ol><li>Thread A 尝试获取 Resource X 的锁。</li><li>Thread B 尝试获取 Resource Y 的锁。</li><li>Thread A 发现 Resource X 的锁已经被 Thread B 获取，它释放 Resource X 的锁并等待。</li><li>Thread B 发现 Resource Y 的锁已经被 Thread A 获取，它释放 Resource Y 的锁并等待。</li><li>Thread A 和 Thread B 同时重新尝试获取资源的锁。</li><li>重复步骤 3 和步骤 4 。</li></ol><p>在这个例子中，Thread A 和Thread B 由于竞争资源而无法进展，导致它们不断尝试重新获取资源的锁，但最终都无法成功。这种情况下，线程们一直在等待对方释放资源，而没有任何一个线程能够进一步执行，形成了活锁。</p><p>为了解决活锁问题，可以使用一些策略，如引入随机性的等待时间、重新尝试获取资源的锁的顺序调整或者引入一个调度策略来打破竞争的循环，以确保线程能够顺利地获取资源并继续执行。</p><h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>任务可以分优先级，在调度时，高优先级的任务在需要执行时可以打断低优先级任务的执行。优先级反转是这样一种情况：</p><ol><li>有 3 个线程，优先级由高到低分别是：<em>线程 1</em>、<em>线程 2</em>、<em>线程 3</em>；</li><li>有一个共享资源，<em>线程 1</em> 与<em>线程 3</em> 需要访问这个共享资源；</li><li>最低优先级的<em>线程 3</em> 持有共享资源的锁，正在执行；</li><li><em>线程 1</em> 打断了<em>线程 3</em> 的执行，但是因为未获得锁，休眠了；</li><li><em>线程 2</em> 获得了时间片，得以执行；</li><li><em>线程 3</em> 继续执行，并释放了锁；</li><li>最高优先级的<em>线程 1</em> 终于可以执行；</li></ol><p>上述的过程中，虽然<em>线程 1</em> 有着最高优先级，但实际上却是最后才能执行，这样的情况就是<strong>优先级反转（Priority Inversion）</strong>。</p><h2 id="无阻塞算法"><a href="#无阻塞算法" class="headerlink" title="无阻塞算法"></a>无阻塞算法</h2><blockquote><p>没学会…</p></blockquote><p>无阻塞算法（Non-blocking algorithm）常被称为“无锁编程”。无锁编程常被理解为“没有使用互斥锁的编程算法”，这个理解是正确的，因为只要使用了锁就不会是无阻塞算法，但没有反映出“无阻塞”的本质。</p><p>wait-free、lock-free 和 obstruction-free。</p><p>其中 lock-free 指的是不会导致<strong>总体任务进度</strong>被<strong>锁住（lock up）</strong>的算法，而不是不用互斥锁的算法。</p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><h2 id="基于事件的并发"><a href="#基于事件的并发" class="headerlink" title="基于事件的并发"></a>基于事件的并发</h2><blockquote><p>未完待续…</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有许多关于并发编程的内容来自于《操作系统导论》，这是我当时阅读这本书时意想不到的。</p><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><ul><li>2023-07-15: 完成后半部分；</li><li>2022-08-22: 只完成了小部分内容；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前接触 C++ Coroutine 的时候，看到了开源代码中关于内存序(memory order)的使用，于是想要了解一下这个内存序到底是个什么东西。结果发现相关的知识体系非常庞大，想要真正搞懂内存序是怎么来的、有什么用和什么时候用，需要搞清楚的东西根本不是一两天能学会的。本来只是想了解下内存序是什么，结果一不小心从《计算机体系结构》、《操作系统导论》一路学到了并发编程……&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="https://uint128.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://uint128.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>百度网盘导致资源管理器(explorer)崩溃</title>
    <link href="https://uint128.com/2022/05/21/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%AF%BC%E8%87%B4%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-explorer-%E5%B4%A9%E6%BA%83/"/>
    <id>https://uint128.com/2022/05/21/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%AF%BC%E8%87%B4%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-explorer-%E5%B4%A9%E6%BA%83/</id>
    <published>2022-05-21T05:34:29.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>我对百度网盘的评价是：用户体验极差的毒瘤软件。<br><span id="more"></span></p><p>突然发现电脑的资源管理器打不开了，一打开资源管理器就会卡住，开始菜单打不开，任务栏也无响应。</p><p>对于资源管理器崩溃的问题，通常在“可靠性历史记录”里找崩溃的原因。</p><p>可以在 Windows 搜索里直接搜索“可靠性”或者 “控制面板 -&gt; 系统和安全 -&gt; 查看你的计算机状态 -&gt; 维护 -&gt; 查看可靠性历史记录” 查看可靠性历史记录。</p><p><img src="1.png" alt=""></p><p>打开之后，可以发现最近一段时间的计算机可靠性，错误越多可靠性越低。（我这个问题持续了有一段时间了，实在是烦了才抽时间找原因）</p><p><img src="2.png" alt=""></p><p>点击 “查看技术详细信息”，一般来说运气好的话，直接能找到一些蛛丝马迹。比如说第三方程序的进程，那么这个崩溃很有可能就是对应的程序导致了，卸载了也许就好了。</p><p>我之前遇到过一次金山毒霸导致的资源管理器崩溃，在详细信息里看到了“kingsoft”字样，于是我把电脑里的所有金山的软件都卸载了，果然就好了。</p><p>但是这次没有找到什么有用信息，于是我进一步点击 “查看啥啥文件”（我给忘了，没截图）。</p><p>之后会打开临时目录下的一个文件夹，里面有一个 memory.hdmp 文件。</p><p>用 Visual Studio 可以打开它，拉到最下面，能发现一些第三方软件的模块。</p><p>看到 YunShellExtV164.dll 的路径，就知道它是百度网盘的玩意。</p><p>把百度网盘卸载了，问题解决。</p><p><img src="3.png" alt=""></p><p>实际上那些第三方模块都有可能是导致崩溃的罪魁祸首，之所以第一个挑百度网盘卸载，是因为它的用户体验实在是太差了，让我不得不怀疑它的制作水平。</p><p>我觉得我只需要罗列一下它的问题，就能感受到百度网盘的用户体验有多差：</p><ol><li>打开百度网盘的时候静默更新，没有任何的窗口提示。百度网盘那么大的体积做不到秒下载秒更新，静默更新居然不给个提示？我一度以为百度网盘崩溃了。</li><li>卸载程序居然也会触发自动更新。我<del>tmd</del>想卸载百度网盘还得更新到最新版。而且也是静默更新，我在任务管理器盯着他完成更新下载。</li><li>把自己装到不需要管理员权限的目录下（用户数据目录），违反了微软的软件开发规范，只为了方便自己往用户电脑里拉屎。</li><li>基于 electron 的桌面软件开发技术已经很成熟了，但是百度网盘的UI在高分屏下显示很差劲。我甚至找不到和他一样UI差劲的国产软件，在这一方面成为国产之最当之无愧。</li><li>用很恶心的方法引导用户将数据备份到百度网盘，这一点在手机客户端做的尤其过分，同意备份的按钮做得特别大，不小心一点很容易点到。</li><li>客户端里的广告多且恶心，比如注册贷款软件送会员，相当于用身份证、银行卡等信息换几天的会员。</li></ol><p>我对百度网盘的评价是：用户体验极差的毒瘤软件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我对百度网盘的评价是：用户体验极差的毒瘤软件。&lt;br&gt;</summary>
    
    
    
    
    <category term="其他" scheme="https://uint128.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>快速入门LS-DYNA:基本概念</title>
    <link href="https://uint128.com/2022/05/20/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8LS-DYNA-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://uint128.com/2022/05/20/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8LS-DYNA-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-05-20T08:22:17.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>本科毕业论文要用 LS-DYNA 进行有限元仿真，有一些基本概念发现很多资料、书籍都没说清楚，结合自己的理解浅谈一下。<br><span id="more"></span></p><h2 id="LS-PrePost和LS-DYNA"><a href="#LS-PrePost和LS-DYNA" class="headerlink" title="LS-PrePost和LS-DYNA"></a>LS-PrePost和LS-DYNA</h2><p>有限元分析的基本工作流程总体分为三步：前处理、数值计算、后处理。</p><p>LS-DYNA 这个程序就是做第二步的数值计算工作，它读取 .k 文件，并生成一系列计算结果文件。所以要完成一次有限元分析，实际上学的并不是 <strong>LS-DYNA</strong> 这个程序如何使用，<strong>更多的还是在学如何进行前处理和后处理</strong>。关于 LS-DYNA，其实学的是其进行有限元分析的理论，而不是程序使用的方法。</p><blockquote><p>我得强调这一点，因为我刚开始查资料的时候，搜索关键词都是 “LS-DYNA 如何如何…”。但实际上我的疑问都是关于前处理方面的，以 LS-DYNA 为关键词导致我什么资料都没搜出来。</p></blockquote><p>在数值计算之前，需要建立有限元模型，这属于第一步的前处理的工作。</p><p>进行前处理工作的软件有很多，比如 Ansys、LS-PrePost 等。其中 LS-PrePost 是最合适的，因为它是专门为 LS-DYNA 设计的前处理软件（LS-PrePost 也有后处理功能，所以它叫“Pre + Post”）。</p><p>虽然 LS-DYNA 是收费的商用有限元软件，但是 LS-PrePost 却是免费的，最好使用最新版。</p><h2 id="有限元分析的前处理"><a href="#有限元分析的前处理" class="headerlink" title="有限元分析的前处理"></a>有限元分析的前处理</h2><p>在有限元分析中，前处理的工作量可能是最大的。我本科毕业论文研究的是碰撞问题，那么这种碰撞问题的前处理工作通常包括：绘制几何模型、建立有限元模型、选择材料参数、设置接触条件和计算终止条件等。</p><p>LS-PrePost 有几何模型的绘制功能，但是我觉得不太好用，我更习惯用 AutoCAD 和 Solidworks 绘制几何模型。LS-PrePost 支持导入 .IGES、.ST(E)P、.STL 格式的几何模型文件，所以在绘制几何模型上可以选用别的软件进行，再通过这些文件将几何模型导入到 LS-PrePost 继续前处理的工作。</p><p>LS-PrePost 导入几何模型之后，就可以进行其他的工作，比如简化模型、网格划分等等。</p><p>对于网格划分，也可以使用更强大的 HyperMesh，这需要多花一点时间去学习。我做毕业论文的时候只剩下两个月不到了，就没时间学这玩意。</p><h2 id="理解-k文件和LS-DYNA的基本关键词"><a href="#理解-k文件和LS-DYNA的基本关键词" class="headerlink" title="理解.k文件和LS-DYNA的基本关键词"></a>理解.k文件和LS-DYNA的基本关键词</h2><p>前处理工作的最终结果是得到一个（或若干个） .k(.key) 文件，k 指的是 keyword，因为 LS-DYNA 的有限元模型是由一个个关键词描述的。.k 文件是纯文本文件，可以用文本编辑器查看、修改。</p><blockquote><p>.k 文件里是不包含几何模型的，所以如果觉得网格划分不满意，那么只能重新导入原来的几何模型文件（比如 .IGES 文件），重新进行网格划分工作。</p></blockquote><p>要理解 LS-DYNA 中关于 <code>*Part</code>、<code>*Element_&#123;option&#125;</code>、<code>Section_&#123;option&#125;</code> 等关键词的区别和联系，需要先了解 .k 文件是如何描述有限元模型的：<strong>.k文件的本质就是个关系型数据库</strong>。</p><h3 id="Part-关键词"><a href="#Part-关键词" class="headerlink" title="*Part 关键词"></a>*Part 关键词</h3><p>描述一个实体，该实体有相同的材料（由 <code>*MAT_&#123;&#125;</code> 系列关键词设置）、相同的单元类型（Shell、Solid等）和单元属性（由 <code>*Section_&#123;&#125;</code> 系列关键词设置），组成该实体的各个单元使用 <code>*Element_&#123;&#125;</code> 系列关键词描述。</p><blockquote><p>*Part 就是个关系表，将多个 Element 组装成一个 Part，同时赋予材料属性（MAT）、单元类型和单元属性（Section）</p></blockquote><h3 id="Node-关键词"><a href="#Node-关键词" class="headerlink" title="*Node 关键词"></a>*Node 关键词</h3><p>描述空间直角坐标系（LS-DYNA 只有三维直角坐标系）中的各个节点。</p><h3 id="Element-Option-关键词"><a href="#Element-Option-关键词" class="headerlink" title="*Element_{Option} 关键词"></a>*Element_{Option} 关键词</h3><p>一个 Elment 描述一个单元的类型和组成该单元的各个节点。Part 和 Element 属于一对多关系，一个 Part 可以由多个  Element 来描述，组合成形状复杂的实体。</p><p>对于 Element_Shell，每个单元需要 4 个节点来描述（四个节点中可能有两个点是相同的，表明这是一个三角形单元）。对于 Element_Solid，每个单元需要 8 个节点描述。</p><h3 id="Section-Option-关键词"><a href="#Section-Option-关键词" class="headerlink" title="*Section_{Option} 关键词"></a>*Section_{Option} 关键词</h3><p>一个Section用于对某种单元类型设置相应的属性，比如 Shell 类型单元可以设置厚度属性。同一种单元类型可以创建多个Section，也就是说可以创建多个 <code>Section_Shell</code> 然后分别设置不同的厚度。</p><h3 id="Segment-关键词"><a href="#Segment-关键词" class="headerlink" title="*Segment 关键词"></a>*Segment 关键词</h3><p>一个单元某个方向上的面。对于 Solid 类型单元，可能是六面体，因此该单元有 6 个 Segment。若干单元在某个方向上的Segment 可以组成一个集合，用 <code>*SET_Segment</code> 关键词描述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>突然发现本文的标题具有误导性，这篇文章并不能带你入门，但是它的内容又刚好是入门者需要的。<br>我学习 LS-DYNA 的资料主要是《LS-DYNA3D理论基础与实例分析》、《LS-DYNA动力学分析指南》和 dynasupport.com 网站的资料。这两本书对这些常见关键词的描述真的太模糊了，光靠直觉根本理解不了。后来我才发现其实 .k 文件的本质就是个关系型数据库，用关系表、实体表的角度去看这些关键词，豁然开朗，就很清晰通透。于是我写了这篇博文，或许刚好就能帮到你。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本科毕业论文要用 LS-DYNA 进行有限元仿真，有一些基本概念发现很多资料、书籍都没说清楚，结合自己的理解浅谈一下。&lt;br&gt;</summary>
    
    
    
    
    <category term="ls-dyna" scheme="https://uint128.com/tags/ls-dyna/"/>
    
  </entry>
  
  <entry>
    <title>给博客换了个新主题</title>
    <link href="https://uint128.com/2022/05/19/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%BA%86%E4%B8%AA%E6%96%B0%E4%B8%BB%E9%A2%98/"/>
    <id>https://uint128.com/2022/05/19/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%BA%86%E4%B8%AA%E6%96%B0%E4%B8%BB%E9%A2%98/</id>
    <published>2022-05-19T04:50:17.000Z</published>
    <updated>2022-08-22T09:11:21.054Z</updated>
    
    <content type="html"><![CDATA[<p>毕业论文取得了阶段性进展，终于可以腾出时间搞点别的事情了，先给博客换了个新主题，好久没写东西了。<br><span id="more"></span></p><p>我觉得新主题比旧主题更精致一点，一贯的简约风格但是更有高级感？换了主题后感觉心情都好了些。</p><p>新主题的代码高亮支持浅色方案，和主题很搭。新主题还支持夜间模式（原始版本的主题不支持，<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/564">这个大佬的魔改版</a>支持），走在设计趋势的前沿了。</p><p>比较遗憾的是评论全都没了。之前所用的 GitTalk 版本比较旧，对于中文标题的博文很大概率无法创建评论 Issues，被我魔改了一下。现在新版对中文标题支持变好了，我就不做魔改了，原来的评论没了就没了吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕业论文取得了阶段性进展，终于可以腾出时间搞点别的事情了，先给博客换了个新主题，好久没写东西了。&lt;br&gt;</summary>
    
    
    
    
    <category term="其他" scheme="https://uint128.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>使用EndNote管理文献</title>
    <link href="https://uint128.com/2022/04/03/%E4%BD%BF%E7%94%A8EndNote%E7%AE%A1%E7%90%86%E6%96%87%E7%8C%AE/"/>
    <id>https://uint128.com/2022/04/03/%E4%BD%BF%E7%94%A8EndNote%E7%AE%A1%E7%90%86%E6%96%87%E7%8C%AE/</id>
    <published>2022-04-03T11:43:18.000Z</published>
    <updated>2022-08-22T09:11:21.019Z</updated>
    
    <content type="html"><![CDATA[<p>毕业论文要求使用 Word 来写，就想用 Word 插件来管理引用文献，记录一下使用时遇到的问题和解决方法。我使用的是 EndNote 20，本文的方法在其他版本可能不适用。<br><span id="more"></span></p><h2 id="使用-GB-T7714-Style"><a href="#使用-GB-T7714-Style" class="headerlink" title="使用 GB/T7714 Style"></a>使用 GB/T7714 Style</h2><p>在菜单栏中点击 <strong>Tools/Output Sytle/Open Style Manager…</strong>，打开样式管理器。</p><p><img src="pic002.png" alt=""></p><p>点击样式管理器中的 <strong>Get more on the web</strong> 按钮，就会<a href="https://endnote.com/downloads/styles/">打开一个网页</a>，在这个网页里搜索 <strong>Chinese Standard</strong> 就能找到两个国标样式了，全都下载下来。</p><p><img src="pic001.png" alt=""></p><p>将下载得到的两个样式文件放到 EndNote 安装目录的 Style 目录下，比如我的是 <code>C:\Program Files (x86)\EndNote 20\Styles</code>。</p><p>然后回到 Style Manager，把两个国标样式都勾选上，再打开你的 Word 文档，就可以选择国标样式了。</p><p><img src="pic003.png" alt=""></p><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="中文期刊只显示前三位作者"><a href="#中文期刊只显示前三位作者" class="headerlink" title="中文期刊只显示前三位作者"></a>中文期刊只显示前三位作者</h3><p>对于作者数量大于 3 位作者的期刊，我们的毕业论文格式要求只显示前 3 位作者，然后在后面加上 “et al.” 或者 “, 等”。</p><p>对于英文期刊来说当然用 “et al.”，但是对于中文期刊来说，应该使用 “, 等”。</p><p>EndNote 下载的国标格式，不论英文期刊还是中文期刊，都显示的“et al.”。这是因为不论英文期刊还是中文期刊，都被视为一种文献类型：“Journal Article”。</p><p>要对中文期刊做特别设置，就要新创建一种文献类型。</p><p>点击菜单栏 <strong>Edit/Preferences</strong> 打开设置页面，点击 <strong>Reference Types</strong>。</p><p>如图所示，在 <strong>Default Reference Type</strong> 中选择 <strong>Unused 1</strong>（因为我已经设置过了，所以图中只剩下Unused 2/3）。</p><p><img src="pic004.png" alt=""></p><p>然后点击 <strong>Modify Reference Type</strong> 按钮，如图填写设置。</p><p><img src="pic005.png" alt=""></p><p>保存之后就创建了“中文期刊”这种文献类型，现在要对这种类型进行设置。</p><p>在菜单  <strong>Tools/Output Sytle/</strong> 中勾选 <strong>Chinese Std GBT7714(numeric)</strong>。然后再再到菜单  <strong>Tools/Output Sytle/</strong> 中点击 <strong>Edit “Chinese Std GBT7714(numeric)”</strong>，进入编辑界面。</p><p>在编辑界面，首先在菜单 <strong>File/Save as</strong> 另存为新的样式，比如我取名为 <strong>Chinese Std GBT7714(numeric) Fix</strong>，避免影响下载的国标样式。</p><p>然后如图所示，修改 <strong>Editor Lists</strong> 中的设置，将原来的 <strong>“, et al.”</strong> 替换为 <strong>“, 等”</strong>。</p><p><img src="pic006.png" alt=""></p><p>这里<strong>不要</strong>修改 <strong>Author Lists</strong> 中的设置。因为这两个设置是不限定文献类型的，也就是说英文期刊和中文期刊都会受到影响。而我们对英文期刊和中文期刊分别设置的原理就是将 Author Lists 的设置应用于英文期刊，而 Editor Lists 的设置应用于中文期刊。</p><p>接下来编辑中文期刊的 Style 模板。如图所示，点击 Reference types 按钮，勾上 “中文期刊”类型，然后写入如下模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Secondary Author. Title [J]. Journal, Year|, Volume|(Issue)| : Pages|.</span><br></pre></td></tr></table></figure><p>注意，这里用的不是 Author 而是 Secondary Author。这里的 Secondary Author 会使用前面 “Editor Lists” 的设置，这就是对英文文献和中文文献使用不同设置的原理。对于英文文献，其 Reference Type 为 “Journal Article”，模板中使用的是 “Author”，则会应用 “Author Lists” 的设置。</p><p>还要注意，这里的 “|” 和 “°” 都不是普通文本，不能用复制粘贴的方式填入，应该在右上角的 “Insert Field” 按钮中插入。</p><p>其中“Foced Separation” 对应 “|”，“Link Adjacent Text” 对应 “°”，空格对应“·”。</p><p><img src="pic007.png" alt=""></p><p>我这里的模板是经过调整的，对于那些没有卷号的期刊，也可以正确显示。（如果使用 Journal Article 的模板，没有卷号的期刊会显示多余的逗号和空格）</p><p>保存修改，接下来的操作是把中文期刊的文献类型修改为“中文期刊”。</p><p>在文献列表中双击你要修改的文献，然后如图所示将 Reference Type 修改为 “中文期刊”。</p><p><img src="pic008.png" alt=""></p><p>将所有的中文期刊的 Reference Type 都修改为“中文期刊”后，接下来要编辑它们的 “Secondary Author”。</p><p>首先创建一个 Smart Group，将所有的“中文期刊”都列出来，具体方法是右键左侧的 “MY GROUPS”，点击 “Create smart group”。</p><p><img src="pic009.png" alt=""></p><p>切换到刚刚创建的 Smart Group，这时候列表里只有 Reference Type 为 “中文期刊” 的文献。</p><p>然后点击菜单栏的 <strong>Library/Change/Move/Copy Fields</strong>，按照如图所示设置，将 Author 的值复制到 Secondary Author。</p><p><img src="pic010.png" alt=""></p><p>然后，回到 Word 里更新引用，作者数量大于三位的文献应该会使用正确的格式显示了。</p><h3 id="页码显示问题"><a href="#页码显示问题" class="headerlink" title="页码显示问题"></a>页码显示问题</h3><p>下载的国标样式的页码显示方式是错误的，要修改为显示完整的页码，其设置方法如图所示。</p><p><img src="pic011.png" alt=""></p><h3 id="不要全大写的作者名称"><a href="#不要全大写的作者名称" class="headerlink" title="不要全大写的作者名称"></a>不要全大写的作者名称</h3><p>下载的国标样式中，英文文献的作者是字母全大写的，要修改为首字母大写，其设置方法如图所示。</p><p><img src="pic012.png" alt=""></p><h2 id="中英文混排的-Word-样式调整"><a href="#中英文混排的-Word-样式调整" class="headerlink" title="中英文混排的 Word 样式调整"></a>中英文混排的 Word 样式调整</h2><p>中英文混合排版主要的问题是字体设置，中文使用宋体，英文使用 Times New Roman 字体。但是 EndNote 的设置只支持设置一种字体，如下图所示。</p><p><img src="pic013.png" alt=""></p><p>我找到的一种解决方法是，在 EndNote 的字体设置中设置英文字体：Times New Roman。然后再修改 “EndNote Bibliography” 的字体样式，将中文字体修改为宋体。</p><p><img src="pic014.png" alt=""></p><p>很奇怪的是，对“EndNote Bibliography”的段落样式进行修改是无效的，每次更新都会被覆盖，我也不知道应该在哪里进行设置。</p><p>段落样式在 EndNote 的设置里可以设置一些简单的参数，如上上图所示，可以修改的项目有：首行缩进、行间距、悬挂缩进、后置字符。</p><p>其中行间距只支持单倍行距、1.5倍行距和双倍行距，不支持设置固定值，这点不太灵活。</p><p>只能在交稿之前手动修改参考文献列表的样式，不能完全自动化了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕业论文要求使用 Word 来写，就想用 Word 插件来管理引用文献，记录一下使用时遇到的问题和解决方法。我使用的是 EndNote 20，本文的方法在其他版本可能不适用。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>理解C++20 Coroutine: Promise type</title>
    <link href="https://uint128.com/2022/03/02/%E7%90%86%E8%A7%A3C-20-Coroutine-promise-type/"/>
    <id>https://uint128.com/2022/03/02/%E7%90%86%E8%A7%A3C-20-Coroutine-promise-type/</id>
    <published>2022-03-02T01:34:03.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>理解C++20 Coroutine: promise type<br><span id="more"></span></p><p>这是我学习 C++20 Coroutine 笔记的第三篇，打算做成一个系列，如果感兴趣可以从头开始读：</p><ol><li><a href="https://uint128.com/2022/02/16/%E7%90%86%E8%A7%A3-C-20-Coroutine-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/">理解 C++20 Coroutine: 协程的概念</a></li><li><a href="https://uint128.com/2022/02/21/%E7%90%86%E8%A7%A3C-20-Coroutine-co-await%E4%B8%8EAwaiter/">理解C++20 Coroutine: co_await与Awaiter</a></li></ol><p>本文的主要参考文献是 <a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">C++ Coroutines: Understanding the promise type</a>，建议直接读原文而不是我的笔记。</p><h2 id="Promise-objects"><a href="#Promise-objects" class="headerlink" title="Promise objects"></a>Promise objects</h2><p>前面的笔记提到过，Promise object 是用来控制协程的行为的。</p><p>promise type 的实例 promise object 会在每次调用协程时被创建。然后编译器会为协程函数的调用生成一些代码，在协程执行到特定点时调用 promise 特定的函数。</p><p>举例说明，假设有一个协程被调用之后，创建了一个 promise object: promise，那么对于这个协程的调用可能会是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">co_await</span> promise.<span class="built_in">initial_suspend</span>();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    &lt;body-statements&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (...)</span><br><span class="line">  &#123;</span><br><span class="line">    promise.<span class="built_in">unhandled_exception</span>();</span><br><span class="line">  &#125;</span><br><span class="line">FinalSuspend:</span><br><span class="line">  <span class="keyword">co_await</span> promise.<span class="built_in">final_suspend</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;body-statements&gt;</code> 是协程的代码。</p><p>相比于普通函数调用，协程的调用会额外多一些步骤：</p><ol><li>通过 operator new 分配协程帧(coroutine frame)；(可选步骤)</li><li>复制所有函数参数到协程帧；</li><li>调用 promise type 的构造函数，得到 promise object: promise。</li><li>调用 promise.get_return_object() 来获取协程第一次返回时的返回结果；</li><li>调用 promise.initial_suspend() 并 co_await 它的返回结果；</li><li>当 co_await promise.initial_suspend() 恢复执行(resume)，你所编写的协程主体代码开始执行。</li></ol><p>当执行遇到 co_return 时执行的一些额外的步骤：</p><ol><li>调用 promise.return_void() 或 promise.return_value(<code>&lt;expr&gt;</code>)；</li><li>以创造它们的反向顺序销毁所有局部变量；</li><li>调用 promise.final_suspend() 并 co_await 它的返回结果；</li></ol><p>或者，执行因为遇到未处理异常而退出，那么：</p><ol><li>捕获该异常并在 catch-block 调用 promise.unhandled_exception()；</li><li>调用 promise.final_suspend() 并 co_await 它的返回结果；</li></ol><p>一旦协程主体的代码执行完毕，协程帧就会被销毁，销毁步骤包括：</p><ol><li>调用 promise object 的析构函数；</li><li>调用函数参数副本的析构函数；</li><li>调用 operator delete 来释放协程帧的内存；(可选步骤)</li><li>将执行迁移回 caller/resumer；</li></ol><h2 id="分配协程帧"><a href="#分配协程帧" class="headerlink" title="分配协程帧"></a>分配协程帧</h2><p>传递给 operator new 的大小不是 sizeof(promise type)，而是整个协程帧的大小，包括所有函数参数的大小、promise object 的大小、局部变量的大小和编译器用于管理协程状态的内存大小。</p><p>作为一种优化，编译器可能不会使用 operator new 分配协程帧。</p><ol><li>it is able to determine that the lifetime of the coroutine frame is strictly nested within the lifetime of the caller; and</li><li>the compiler can see the size of coroutine frame required at the call-site.</li></ol><p>在这种情况下，编译器可以将协程帧分配到调用者的激活帧中（栈帧(stack-frame) 或 协程帧(coroutine-frame) 都有可能）。</p><p>promise type 可以定义 operator new() 的重载来替换全局的 operator new。</p><h2 id="复制参数到协程帧"><a href="#复制参数到协程帧" class="headerlink" title="复制参数到协程帧"></a>复制参数到协程帧</h2><p>如果参数以值传递的方式(pass-by-value)，那么会调用移动构造函数复制到协程帧。</p><p>如果参数以引用传递的方式(pass-by-reference)，无论是左值还是右值，都只有引用会被复制到协程帧。</p><h2 id="构造-promise-object"><a href="#构造-promise-object" class="headerlink" title="构造 promise object"></a>构造 promise object</h2><p>在复制所有参数到协程帧之后会构建 promise object，这种设计允许你在构造 promise object 时（构造函数内）可以访问这些参数。</p><h2 id="获取返回对象"><a href="#获取返回对象" class="headerlink" title="获取返回对象"></a>获取返回对象</h2><p>成功构造 promise object 后的第一件事情就是通过调用 promise.get_return_object() 获取返回对象。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;理解C++20 Coroutine: promise type&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>理解C++20 Coroutine: co_await与Awaiter</title>
    <link href="https://uint128.com/2022/02/21/%E7%90%86%E8%A7%A3C-20-Coroutine-co-await%E4%B8%8EAwaiter/"/>
    <id>https://uint128.com/2022/02/21/%E7%90%86%E8%A7%A3C-20-Coroutine-co-await%E4%B8%8EAwaiter/</id>
    <published>2022-02-20T18:16:20.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>理解C++20 Coroutine: co_await与Awaiter<br><span id="more"></span></p><p>这是我学习 C++20 Coroutine 笔记的第二篇，打算做成一个系列，如果感兴趣可以从头开始读：</p><ol><li><a href="https://uint128.com/2022/02/16/%E7%90%86%E8%A7%A3-C-20-Coroutine-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/">理解 C++20 Coroutine: 协程的概念</a></li></ol><p>这篇笔记参考的原文是：<a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">C++ Coroutines: Understanding operator co_await</a>，更推荐大家直接看原文，因为原文写的就很好，我的笔记大部分都是翻译的原文。</p><h2 id="协程提案给我们提供了什么？-What-does-the-Coroutines-TS-give-us"><a href="#协程提案给我们提供了什么？-What-does-the-Coroutines-TS-give-us" class="headerlink" title="协程提案给我们提供了什么？(What does the Coroutines TS give us?)"></a>协程提案给我们提供了什么？(What does the Coroutines TS give us?)</h2><ol><li>三个新关键词：<code>co_await</code>、<code>co_yield</code>、<code>co_return</code>。</li><li>几个新类型：<ol><li><code>coroutine_handle&lt;P&gt;</code></li><li><code>coroutine_traits&lt;Ts…&gt;</code></li><li><code>suspend_always</code></li><li><code>suspend_never</code></li></ol></li><li>一套通用的机制，库的编写者可以使用它与协程交互并自定义协程的行为。</li><li>一种使得编写异步代码更简单的语言工具。</li></ol><p>C++20 协程提案所提供的工具可以被认为是协程版的“低级汇编语言”。这些工具很难被安全地、直接地使用，它们的主要目的是让库的编写者去构建其他开发者可以安全使用的、高度抽象的程序。</p><h2 id="编译器和库之间的交互（Compiler-lt-gt-Library-interaction）"><a href="#编译器和库之间的交互（Compiler-lt-gt-Library-interaction）" class="headerlink" title="编译器和库之间的交互（Compiler &lt;-&gt; Library interaction）"></a>编译器和库之间的交互（Compiler &lt;-&gt; Library interaction）</h2><p>协程提案实际上并没有定义协程语义。它没有定义如何产生返回给调用者的值。它没有定义如何处理传递给 co_return 语句的返回值或如何处理从协程传播的异常。它也没有定义协程将会在哪一条线程恢复运行。</p><p>取而代之的是，它为库代码指定了一种通用的机制，可以通过实现符合特定接口的类型以定制协程的行为。编译器会生成调用这个类型实例方法的代码。这种方法类似于库编写者可以通过定义 begin()/end() 方法来自定义 range-based for-loop。</p><p>事实上，协程提案没有规定任何特定的协程机制语义使得它成为了一个很强大的工具。这允许库的编写者可以为了各种不同的目的，定义不同类型的协程。</p><p>举例来说，你可以定义一个协程，它异步地产生一个值；或者定义一个协程，它“懒惰地”（lazily）产生一系列值（即在需要时才计算值，而不是预先计算出整个序列再返回其中一个）；或定义一个协程来简化控制流程，如果 <code>std::optional&lt;T&gt;</code> 的值是 <code>std::nullopt</code>，那么就尽早退出执行。</p><p>协程提案定义了两种接口：<strong>Promise 接口</strong>和 <strong>Awaiter 接口</strong>。</p><blockquote><p>!注意，这里原文用的是 Awaitable 接口，但是我觉得应该用 Awaiter 接口，因为下文提到：“实现了三个方法的类型称为 Awaiter 类型”，那么这三个方法所对应的接口称为 Awaiter 接口会更容易理解，因此我这里采用了“Awaiter 接口”。</p><p>这里的接口指的就是面向对象里接口的含义。只要你的类型实现了标准所指定的一系列函数，也就是实现了 Promise 接口 或 Awaiter 接口，那么这个类型就是 Promise type 或 Awaiter type。</p></blockquote><p><strong>Promise 接口指定了一些方法来控制协程自身的行为。</strong>库的编写者可以自定义当协程被调用时会发生什么、当协程返回时会发生什么（这里的返回既可以指寻常意义的函数返回，也可以指因为未捕获的异常而退出）、以及自定义协程内所有 co_await 或 co_yield 表达式的行为（这里指的是 await_transform 的工作）。</p><p><strong>Awaiter 接口指定了一些方法来控制 co_await 表达式的语义。</strong>当一个值被 co_await 时，代码会被翻译成 awaitable 对象的一系列方法的调用。Awaiter 接口允许你：是否挂起当前的协程(1)、当协程已经挂起后执行额外的逻辑来安排协程之后何时恢复执行、在协程恢复执行并产生 co_await 表达式的结果后执行一些逻辑。</p><blockquote><p>(1).比如一种可以被多次 co_await 的设计，第一次会挂起进行计算并保存计算结果，之后再co_await 都直接返回计算结果而无需挂起</p></blockquote><h2 id="Awaiter和Awaitable-解释operator-co-await-Awaiters-and-Awaitables-Explaining-operator-co-await"><a href="#Awaiter和Awaitable-解释operator-co-await-Awaiters-and-Awaitables-Explaining-operator-co-await" class="headerlink" title="Awaiter和Awaitable:解释operator co_await(Awaiters and Awaitables: Explaining operator co_await)"></a>Awaiter和Awaitable:解释operator co_await(Awaiters and Awaitables: Explaining operator co_await)</h2><p>操作符 <code>co_await</code> 是一个新的可以作用于一个值的一元操作符，比如说：<code>co_await someValue</code>。</p><p><strong>操作符 co_await 只能被用于协程中。</strong> 这是一种“恒真逻辑”（tautology）的思想，因为根据定义，所有包含co_await操作符的函数会被编译成协程。</p><blockquote><p>其实我更喜欢 C# 的方式，C# 将带有 async 关键词的方法编译为异步函数，通过关键词这样可以一眼看出一个函数是不是异步函数。<br>而 C++ 的这种方式，协程和普通函数的区别就没那么清晰了。<br>我注意到有人提案添加 async 关键词，类似 C#，将有 async 关键词标记的函数编译为协程。并同时将 co_await、co_yield及co_return分别简化为 await、yield、return。<br>这个提案的结果是“没有达成一致认识”，看来是失败了呢。</p></blockquote><p><strong>一个支持 co_await 操作符的类型被称为 Awaitable 类型(Awaitable type).</strong></p><p>请注意一个类型是否可以被 co_await 操作符应用可以依赖于 co_await 表达式出现的上下文。协程所使用的 Promise type 可以使用它的 await_transform 方法来改变 co_await 表达式的含义。</p><blockquote><p>await_transform 方法我还没有使用过，但是我猜测它可以把一个类型转化为一个 Awaitable 类型。这样一个即使不是 Awaitable 类型（比如std::string），在某些协程里也可以使用： <code>co_await std::string</code> 的用法。</p></blockquote><p>更具体地说，在需要时，我喜欢使用术语 <strong>Normal Awaitable</strong> 来描述在没有 await_transform 成员的协程上下文中支持 co_await 运算符的类型。而且我喜欢使用术语 <strong>Contextually Awaitable</strong> 来描述一种类型，该类型仅在某些类型的协程的上下文中支持 co_await 运算符，因为协程的 promise 类型中存在 await_transform 方法。</p><p>总结：</p><ol><li><strong>Normal Awaitable</strong>：因为实现了 Awaiter 接口而变得 Awaitable 的类型。</li><li><strong>Contextually Awaitable</strong>: 因为 promise type 实现了相关 await_transform 方法而变得 Awaitable 的类型。</li></ol><p>一个 Awaiter 类型是实现了三个特定方法的类型，这些方法作为 co_await 表达式的一部分被调用，这三个特定方法是：<code>await_ready</code>、<code>await_suspend</code>、<code>await_resume</code>。</p><p>请注意，我无耻地从C# async关键词的机制中“借用”了术语 “Awaiter”，该机制是根据 GetAwaiter() 方法实现的，它返回对象的接口类似于C++中Awaiter 的概念。(这里的“我”，是原文的作者，我只是翻译)</p><p><strong>请注意，一个类型可以同时是 Awaitable 类型和 Awater 类型。</strong></p><blockquote><p>实现了这三个方法的类型根据定义自然是一个 Awater type，而 Awaiter 可以被 co_await 关键词应用，天然是 Awaitable type。但是Awaitable type 不一定是 Awater type！比如你可以重载 operator co_await，然后返回一个 Awaiter，这样的类型是 Awaitable type，但是因为没有实现 Awaiter 接口，所以不是 Awaiter type。</p></blockquote><h2 id="获取-Awaiter-Obtaining-the-Awaiter"><a href="#获取-Awaiter-Obtaining-the-Awaiter" class="headerlink" title="获取 Awaiter (Obtaining the Awaiter)"></a>获取 Awaiter (Obtaining the Awaiter)</h2><p>对于被 co_await 的值，编译器做的第一件事情是生成获取 Awaiter 对象的代码。N4680 第 5.3.8(3) 节列出了一些获取 awaiter 对象的步骤。</p><p>让我们假设被 co_await 的协程的 Promise type 是 <code>P</code>，而且变量<code>promise</code> 是当前协程的 Promise object 的左值引用。</p><p>如果 Promise type <code>P</code> 有一个名为 await_transform 的成员函数，那么表达式 <code>&lt;expr&gt;</code> 首先被传入到函数调用 <code>promise.await_transform(&lt;expr&gt;)</code> 中以获取 Awaitable 值，<code>awaitable</code>。</p><p>如果没有 await_transform 成员函数，那么表达式 <code>&lt;expr&gt;</code> 的结果被直接认为是 Awaitable 对象，<code>awaitable</code>。</p><p>然后，如果 Awaitable 对象 <code>awaitable</code> 有一个 <code>operator co_await</code> 操作符重载，那么操作符重载会被调用来获取 Awaiter 对象。反之，<code>awaitable</code> 将用作 awaiter 对象。</p><p>如果把这些流程写成代码，那么两个函数 <code>get_awaitable()</code> 和 <code>get_awaiter()</code> 可能看起来像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get_awaitable</span><span class="params">(P&amp; promise, T&amp;&amp; expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_any_await_transform_member_v&lt;P&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> promise.<span class="title">await_transform</span><span class="params">(<span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(expr))</span></span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get_awaiter</span><span class="params">(Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_member_operator_co_await_v&lt;Awaitable&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;<span class="params">(awaitable)</span>.<span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (has_non_member_operator_co_await_v&lt;Awaitable&amp;&amp;&gt;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> <span class="built_in">co_await</span>(<span class="built_in">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这一段主要是想表达对于 <code>co_await &lt;expr&gt;</code> 这么一行代码，其中这个 <code>&lt;expr&gt;</code> 可以是很多很多种情况。<br>比如 <code>&lt;expr&gt;</code> 可以是一个 Awaiter type 或者 Awaitable type 的 object，那么肯定行得通。<br>又比如 <code>&lt;expr&gt;</code> 可以是一个函数调用，但是它的返回值是 Awaitable type，那么也行得通！<br>再极端点，<code>&lt;expr&gt;</code> 既不是 Awaiter type 也不是 Awaitable type，但是因为协程的 Promise type 实现了相关的 <code>await_transform()</code> 函数，那么这个 <code>co_await &lt;expr&gt;</code> 也是合法的代码。</p></blockquote><h2 id="Awaiting-the-Awaiter"><a href="#Awaiting-the-Awaiter" class="headerlink" title="Awaiting the Awaiter"></a>Awaiting the Awaiter</h2><blockquote><p>这个标题还真不知道怎么翻译好。这一部分主要讲解 C++ 编译器是如何把 <code>co_await &lt;expr&gt;</code> 翻译成一系列 Awaiter 接口的函数调用的。</p></blockquote><p>我们假设将 <code>&lt;expr&gt;</code> 的结果转化为 Awaiter 的逻辑可以封装成上面所说的两个函数，那么对于代码 <code>co_await &lt;expr&gt;</code> 的语义可以被粗糙地翻译为以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaitable = <span class="built_in">get_awaitable</span>(promise, <span class="built_in">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaiter = <span class="built_in">get_awaiter</span>(<span class="built_in">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.<span class="built_in">await_ready</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">handle_t</span> = std::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="type">await_suspend_result_t</span> =</span><br><span class="line">      <span class="keyword">decltype</span>(awaiter.<span class="built_in">await_suspend</span>(<span class="type">handle_t</span>::<span class="built_in">from_promise</span>(p)));</span><br><span class="line"></span><br><span class="line">    &lt;suspend-coroutine&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_void_v&lt;<span class="type">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      awaiter.<span class="built_in">await_suspend</span>(<span class="type">handle_t</span>::<span class="built_in">from_promise</span>(p));</span><br><span class="line">      &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">static_assert</span>(</span><br><span class="line">         std::is_same_v&lt;<span class="type">await_suspend_result_t</span>, <span class="type">bool</span>&gt;,</span><br><span class="line">         <span class="string">&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (awaiter.<span class="built_in">await_suspend</span>(<span class="type">handle_t</span>::<span class="built_in">from_promise</span>(p)))</span><br><span class="line">      &#123;</span><br><span class="line">        &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;resume-point&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.<span class="built_in">await_resume</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 <code>await_suspend()</code> 根据返回值类型可以分为两个版本，void 版本和bool 版本。其中，void 版本无条件地将执行转移回 caller/resumer。而bool 版本允许 awaiter 对象根据条件选择是否立即恢复协程的执行，而不返回到 caller/resumer。</p><p>bool版本的 <code>await_suspend()</code> 方法可以被用于这种情况：awaiter 可以异步地进行计算，但有时也想同步地执行。</p><p>在 <code>&lt;suspend-coroutine&gt;</code> 节点，编译器会生成一些代码来保存当前协程的状态并准备协程的恢复。这包括保存恢复点的地址以及将寄存器中的值保存到协程帧的内存中。</p><p>在 <code>&lt;suspend-coroutine&gt;</code> 的操作完成之后，当前的协程就被认为是处于挂起状态。你能观察挂起的协程的第一个点在 await_suspend() 的调用里。一旦协程被挂起，它就可以被恢复或者销毁。</p><p>函数 <code>await_suspend()</code> 的责任是安排协程在未来的恢复（或销毁）。注意，从 <code>await_suspend()</code> 返回 false 算作是安排协程在当前线程立刻恢复。</p><p>函数 <code>await_ready()</code> 的目的是允许你避免 <code>&lt;suspend-coroutine&gt;</code> 操作的消耗，在某些情况，当你已知要同步地进行，就不需要挂起协程再恢复。</p><p>在 <code>&lt;return-to-caller-or-resumer&gt;</code> 节点，执行会被转移回 caller/resumer，当前栈帧弹出，但是保持协程帧活跃。</p><p>当挂起的协程最终被恢复，则在 <code>&lt;resume-point&gt;</code> 恢复执行。</p><p>函数 await_resume() 的返回值类型就是 co_await 表达式的结果类型。函数 await_resume() 也可以抛出异常，来向外传播 co_await 表达式中的异常。</p><p>请注意，如果一个异常在调用 await_suspend() 时传播出来，那么协程会自动地恢复，并且不会调用 await_resume()。</p><h2 id="协程句柄-Coroutine-Handles"><a href="#协程句柄-Coroutine-Handles" class="headerlink" title="协程句柄(Coroutine Handles)"></a>协程句柄(Coroutine Handles)</h2><p>类型 <code>coroutine_handle&lt;P&gt;</code> 表示协程帧的一个非拥有句柄（non-owning handle），可以通过它来恢复协程的执行或销毁协程帧。它也可以被用来访问协程的 promise object。</p><blockquote><p>什么是 non-owning handle？我不知道怎么翻译好。</p></blockquote><p>概括的说，协程句柄有这些接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">coroutine_handle</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">coroutine_handle</span>&lt;<span class="type">void</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="type">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">coroutine_handle</span> : coroutine_handle&lt;<span class="type">void</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Promise&amp; <span class="title">promise</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(Promise&amp; promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="type">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你实现一个 Awaiter type 时，你将会用到 coroutine_handle 里一个关键的 resume 方法。当某些操作完成时，你想要恢复协程的执行，就调用resume 方法。resume 方法将会在遇到下一个 <code>&lt;return-to-caller-or-resumer&gt;</code> 节点时返回（有两种情况：1.再次遇到 co_await，并且将会再次挂起协程； 2.执行到协程的末尾；）。</p><p>destroy 方法会销毁协程帧，调用所有作用范围内的变量的析构函数，并且释放协程帧所用的内存。你通常不需要（而且应该尽量避免）去调用 destroy 函数，除非你是一个库的作者，正在实现协程的 Promise type。通常来说，协程帧会被某种 RAII 类型所持有，并且来自协程调用的返回值。所以调用destroy 而没有和 RAII 对象协作的话，会导致双重析构的BUG。</p><p>promise 方法返回当前协程的 promise object 的引用。和 destroy 方法一样，它通常只有在你是协程的 promise type 的作者时才会用到。</p><p>通常来说，对于绝大多数的 <strong>Normally Awaitable</strong> 类型，应该使用 <code>coroutine_handle&lt;void&gt;</code> 作为 <code>await_suspend()</code> 方法的参数类型，而不是 <code>coroutine_handle&lt;Promise&gt;</code>。如果考虑为某些协程 Promise type 做特别实现，才使用 <code>coroutine_handle&lt;Promise&gt;</code>。</p><p>方法 <code>coroutine_handle&lt;P&gt;::from_promise(P&amp; promise)</code> 允许你从协程的 Promise object 的引用重新构造 coroutine handle。请注意，你必须确保类型 P 和具体协程的 promise type 相匹配。如果尝试构造一个 <code>cotoutine_handle&lt;Base&gt;</code> 而具体协程的 promise type 是 Derived 会导致未定义行为。</p><p>方法 address()/from_address() 允许你将 coroutine handle 转化为/转化自 一个 void* 指针。</p><p>这主要是为了允许作为“上下文”参数传递到现有的 C-Style API，你在某些情况下实现 Awaiter type 时才会发现它的用处。不过，在我所发现的大多数案例里，需要额外传递信息给这个“上下文”参数。所以我通常将 coroutine_handle 储存在一个 struct 中，然后把 struct 的指针传递给这个“上下文”参数，而不是使用 address 的返回值。</p><h2 id="无需同步的异步代码（Synchronisation-free-async-code）"><a href="#无需同步的异步代码（Synchronisation-free-async-code）" class="headerlink" title="无需同步的异步代码（Synchronisation-free async code）"></a>无需同步的异步代码（Synchronisation-free async code）</h2><p>co_await 操作符的一个强大的设计特性是可以在<em>协程暂停后</em>且<em>将执行返回到caller/resumer之前</em>执行代码。</p><p>这允许 Awaiter object 在协程已经挂起后去初始化异步操作，将已经挂起的协程的 coroutine_handle 传入给异步操作。当异步操作完成后，这可以安全地恢复（可能在另一条线程）而不需要额外的同步。</p><p>当协程恢复之后的第一件事情是调用 await_resume 来获取返回值，并且通常立即销毁 Awaiter object（举例说，await_suspend 里使用 this 指针）。协程是有可能在await_suspend返回之前就运行到结尾、销毁协程和 promise object的。</p><p>所以，在 await_suspend 方法里，一旦协程有可能在另一条线程恢复，你需要确保避免访问 this 指针和协程的promise object(通过.promise()方法)，因为它们可能都已经被销毁了。通常来说，在异步操作开始之后和协程已经被安排恢复，在await_suspend方法里你可以安全地访问的唯一东西就是await_suspend的局部变量。</p><blockquote><p>我看的一脸懵逼，没有相关编程经验，不知道到底说的什么情况。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原文作者很详细地讲解了 <code>co_await &lt;expr&gt;</code> 语句是如何被翻译成 Awaiter 接口的调用的。我感觉原文不适合给初学者了解 C++ 协程，它非常枯燥，而且有很多新概念（我也是写了一些协程代码后，再回头看这篇文章，才顺利地看明白了）。我觉得原文更适合那些希望了解 C++ 协程工作细节的人，绝对值得多次阅读。</p><h3 id="Awaiter-type"><a href="#Awaiter-type" class="headerlink" title="Awaiter type"></a>Awaiter type</h3><p>实现了 Awaiter 接口的类型。</p><p>它用三个函数控制 co_await 表达式如何工作。</p><ol><li><code>bool await_ready();</code> : 表示 co_await 是否要挂起，false -&gt; 挂起。</li><li><code>void/bool await_suspend(coroutine_handle&lt;P&gt;);</code> : 在这个函数里安排何时恢复协程的执行（通过调用 <code>resume()</code> 方法）。</li><li><code>T await_resume()</code> : 在这个函数返回执行的返回值。类型 <code>T</code> 表示 <code>co_await &lt;expr&gt;</code> 表达式的类型。</li></ol><h3 id="Awaitable-type"><a href="#Awaitable-type" class="headerlink" title="Awaitable type"></a>Awaitable type</h3><p>可以被 <code>co_await</code> 的类型。（可以是 Awaiter type 也可以是重载了 operator co_await 的类型）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;理解C++20 Coroutine: co_await与Awaiter&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>理解 C++20 Coroutine: 协程的概念</title>
    <link href="https://uint128.com/2022/02/16/%E7%90%86%E8%A7%A3-C-20-Coroutine-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://uint128.com/2022/02/16/%E7%90%86%E8%A7%A3-C-20-Coroutine-%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2022-02-15T21:06:10.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>理解 C++20 Coroutine: 协程的概念。C++ coroutine 的细节非常的多，但是能查到的资料却不是很多。我一边学习一边记录，打算写很多篇文章来分享我的理解。<br><span id="more"></span></p><p>这篇文章本来是想做成笔记的，但是写着写着就成了翻译。我参考的文章是 <a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">https://lewissbaker.github.io/2017/09/25/coroutine-theory</a>，真的非常推荐大家将他的四篇文章都看完，讲解的非常详细清晰，我的文章不及他的千分之一。</p><p>我是在运行了一些协程的实际应用（cppreference里的一个例子：<a href="https://en.cppreference.com/w/cpp/language/coroutines">switch_to_new_thread</a>）之后才看的这篇文章，所以我还是很容易理解原文中所谓的“执行额外的逻辑”是什么意思。 C++20 所引入的协程只有一套机制，没有更多其它东西了，而这套机制非常的灵活，允许你在协程执行的各个关键节点运行你自己的逻辑代码，这就是“执行额外的逻辑”的含义。</p><p>协程理论（Coroutine Theory）</p><h1 id="协程就是函数"><a href="#协程就是函数" class="headerlink" title="协程就是函数"></a>协程就是函数</h1><p><strong>“普通”</strong>函数（“Normal”function 或称为 subroutine）有两种操作：<strong>调用（Call）</strong>和**返回（Return）。这里的返回，也包括函数因为异常而退出的情况。</p><p>调用操作会创建一个 <strong>“活动帧”（Activation Frame）</strong>，挂起<strong>调用者（Caller）</strong>的执行，然后转移到<strong>被调用函数（function being called）</strong>的开始继续执行。</p><p>返回操作会将返回值传递给调用者，销毁“活动帧”，并让调用者恢复执行。</p><p>关于调用和返回以及活动帧的概念，会在下面进行深入而详细地分析。</p><p><strong>协程（coroutine）</strong>也是函数，因此函数的两种操作协程也有，即协程也支持调用和返回。协程的特点是它还支持额外的三种操作：<strong>挂起（Suspend）</strong>、<strong>恢复（Resume）</strong>和<strong>销毁（Destroy）</strong>。</p><p>挂起操作会暂停协程当前的执行，然后让调用者（Caller）继续执行。与返回操作不同的是，协程的挂起操作不会导致“活动帧”被破坏（这里的活动帧指的是<strong>协程活动帧</strong>）。函数的返回操作只在特定的节点发生，即在 return 关键词处发生返回操作。协程的挂起操作也是如此，只在使用 co_await 或 co_yield 关键词时，才会发生挂起操作。</p><p>恢复操作会恢复被挂起的协程，让它在被挂起的位置继续执行。这个操作会重新建立协程的活动帧（这里的活动帧指的是<strong>栈活动帧</strong>）。</p><p>销毁操作会销毁活动帧，而且不需要恢复协程的执行。用于储存活动帧的内存会被释放。</p><h1 id="活动帧（Activation-Frames）"><a href="#活动帧（Activation-Frames）" class="headerlink" title="活动帧（Activation Frames）"></a>活动帧（Activation Frames）</h1><p>你可以将活动帧认为是一块保持着某个被调用函数状态的内存。这些状态包括所有<strong>函数参数</strong>的值和所有<strong>临时变量</strong>的值。</p><p>对于普通函数，活动帧里也包括<strong>返回地址</strong>。在返回操作发生时，需要通过这个地址才能回到调用者，进而继续向后执行。</p><p>对于普通函数，所有的活动帧都有严格的嵌套的生命周期。这种严格的嵌套允许我们使用一种高效率的内存分配数据结构来分配和释放每一次函数调用的活动帧。（也就是“栈”）</p><p>当一个活动帧被分配到栈时，通常称为 <strong>“栈帧”（stack frame）</strong>。</p><p>这个栈是如此地常用，以至于几乎所有的 CPU 架构都有一个特定的寄存器来存储这个栈的顶端（比如在 x64 架构是 rsp 寄存器）。</p><p>要为新的活动帧分配空间，你只需要根据新活动帧的大小将这个寄存器的值增加。反之，要释放活动帧的空间，你只需要根据活动帧的大小将这个寄存器的值减小。（原文末尾有图片，参考着原文末尾的图片会更好理解。）</p><h1 id="调用操作（The-‘Call’-Operation）"><a href="#调用操作（The-‘Call’-Operation）" class="headerlink" title="调用操作（The ‘Call’ Operation）"></a>调用操作（The ‘Call’ Operation）</h1><p>当一个函数调用另一个函数，调用者必须首先准备好将它自己挂起。</p><p>这个挂起步骤通常包含将所有当前寄存器的值保存到内存。这些值会在将来函数恢复执行时被还原。根据函数的调用约定，调用者和被调用者会协调由谁来保存这些寄存器的值，但是你可以直接地认为这个步骤是调用操作的一部分。</p><p>调用者还会将所有传递给被调用函数的参数保存到新的活动帧，这样被调用函数就可以访问他们。</p><p>最后，调用者将调用者的恢复点地址写入新的活动帧，并将执行转移到被调用函数的开始处。</p><p>在 x86/x64 架构中，最后一个操作有它自己的指令，也就是 call 指令。它将下一条指令的地址写入栈，将栈寄存器递增一个地址的大小，然后跳转到 call 指令指定的地址继续执行。</p><h1 id="返回操作（The-‘Return’-Operation）"><a href="#返回操作（The-‘Return’-Operation）" class="headerlink" title="返回操作（The ‘Return’ Operation）"></a>返回操作（The ‘Return’ Operation）</h1><p>当一个函数使用 return 语句返回时，这个函数首先会将返回值（如果有）储存到调用者可以访问到的地方。这个地方可以认为处于调用者的活动帧也可以认为处于当前函数的活动帧（因为两个函数都能访问它，所以活动帧的边界会因为它而变得模糊）。</p><p>然后，函数会经历以下步骤来销毁活动帧。</p><ol><li>销毁返回点范围内的所有局部变量（调用析构函数）；（返回点之外可能还声明了局部变量，它们可能尚未被初始化，因此不需要析构它们）</li><li>销毁所有参数；</li><li>释放活动帧占用的内存；</li></ol><p>最后，在调用者处恢复执行：</p><ol><li>通过设置栈寄存器以还原调用者的活动帧，并且还原所有的寄存器值，它们可能被函数给破坏了；</li><li>跳转到调用者的恢复点，这个恢复点在调用操作时被储存；</li></ol><p>注意，和调用操作一样，某些调用约定可能将返回操作的一些职责分摊到调用者和被调用者的指令中。</p><h1 id="协程活动帧（Coroutine-activation-frames）"><a href="#协程活动帧（Coroutine-activation-frames）" class="headerlink" title="协程活动帧（Coroutine activation frames）"></a>协程活动帧（Coroutine activation frames）</h1><p>由于协程具有可以被挂起而不销毁活动帧的特点，我们不再能保证活动帧的生命周期是严格嵌套的。这意味着活动帧不能像通常那样被分配到栈中，因此可能要分配到堆中。</p><p>在 C++ 协程提案中有一些规定允许将协程活动帧的内存分配到调用者的活动帧中，如果编译器能够证明协程帧的生命周期严格嵌套在调用者活动帧的生命周期之内。有一个足够聪明的编译器可以在许多情况下避免堆分配。<em>（TODO：需要进一步了解何时可以节约堆分配）</em></p><p>对于协程来说，活动帧可以被分为两部分：一部分需要在协程被挂起时被保留，而另一部分只在协程执行时存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task&lt;&gt; <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">bar</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 不再需要a, 因此 a 不需要在协程被挂起时保留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task&lt;&gt; <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">foo</span><span class="params">(a)</span></span>; <span class="comment">// 跨越了一个挂起点，在第二个挂起点需要a, 因此 a 需要在协程被挂起时保留，分配到堆中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面所示代码，一个不跨越协程挂起点的局部变量 a，它可以被储存在栈中。而跨越了挂起点的局部变量，需要储存到堆中。可以将协程的活动帧逻辑上分成两个部分：</p><ol><li>对于需要在协程被挂起时而不被销毁的活动帧，将会分配到堆中，将这部分称之为<strong>协程帧(coroutine frame)</strong>。</li><li>对于只在协程执行时存在的活动帧，将会分配到栈中，将这部分称为<strong>栈帧(stack frame)</strong>。</li></ol><p>栈帧部分只有在协程执行时存在，并且会在协程挂起时和转移执行到调用者(恢复者)时被释放。</p><h1 id="挂起操作（The-‘Suspend’-operation）"><a href="#挂起操作（The-‘Suspend’-operation）" class="headerlink" title="挂起操作（The ‘Suspend’ operation）"></a>挂起操作（The ‘Suspend’ operation）</h1><h2 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h2><p>使用了 co_await 或 co_yield 关键词的地方就是挂起点。</p><h2 id="挂起时进行的工作"><a href="#挂起时进行的工作" class="headerlink" title="挂起时进行的工作"></a>挂起时进行的工作</h2><p>首先，做好恢复协程的准备：</p><ol><li>将寄存器的值写入到协程帧中；</li><li>将协程的挂起点写入协程帧中（这个工作让后续的恢复操作能够知道从哪里恢复，或者后续的销毁操作能够知道哪些值在范围内并且需要被销毁）；//TODO： 不知道具体是如何工作的<br>当协程准备好被恢复，那么协程就可以被认为是处于挂起状态。</li></ol><p>然后，在协程将执行转移回调用者/恢复者之前，协程有机会去执行一些额外的逻辑。这些额外的逻辑允许访问一个句柄(handle)，用以控制协程稍后如何恢复或销毁。</p><p>在协程进入挂起状态后执行额外逻辑的能力允许不需要同步地安排协程恢复。（TODO：不懂）</p><p>之后，协程可以选择立刻恢复（就是继续执行协程），或者选择将执行转移回调用者/恢复者。</p><p>如果执行被转移回调用者/恢复者，协程活动帧的栈帧部分会被释放并且从栈中弹出。</p><h1 id="恢复操作（The-‘Resume’-operation）"><a href="#恢复操作（The-‘Resume’-operation）" class="headerlink" title="恢复操作（The ‘Resume’ operation）"></a>恢复操作（The ‘Resume’ operation）</h1><p>恢复操作可以在一个处于挂起状态的协程上执行。</p><p>通过调用句柄的 <code>void resume()</code> 方法来执行恢复操作。</p><p>和普通的函数调用一样，对 resume 方法的调用会在转移执行之前分配新的栈帧并且储存调用者的返回地址到栈帧中。</p><p>不一样的是，普通函数调用会将执行转移到被调用函数的开始，恢复操作的 resume 调用会将执行转移到<strong>恢复点(resume-point)</strong>，这个恢复点储存在协程帧中。</p><p>当协程再次遇到挂起点或者执行完毕，resume 方法就会返回。</p><h1 id="销毁操作（The-‘Destroy’-operation）"><a href="#销毁操作（The-‘Destroy’-operation）" class="headerlink" title="销毁操作（The ‘Destroy’ operation）"></a>销毁操作（The ‘Destroy’ operation）</h1><p>销毁操作会销毁协程帧，而且不会恢复协程的执行。</p><p>销毁操作只能作用在处于挂起状态的协程。</p><p>销毁操作和恢复操作很相似，因为它们都重新激活了协程活动帧，包括分配新的栈帧和储存返回地址（调用者）。</p><p>另一个相似的地方是，销毁操作也是需要调用特定的方法，void destroy()。</p><p>不同的地方是，恢复操作会跳转到挂起点之后继续执行，销毁操作会跳转到另一个代码分支。这个代码分支负责析构所有恢复点之前范围内的局部变量，然后释放它们在协程帧中占用的内存。</p><h1 id="协程的调用操作（The-‘Call’-opeartion-of-a-coroutine）"><a href="#协程的调用操作（The-‘Call’-opeartion-of-a-coroutine）" class="headerlink" title="协程的调用操作（The ‘Call’ opeartion of a coroutine）"></a>协程的调用操作（The ‘Call’ opeartion of a coroutine）</h1><p>从调用者的角度来说，和普通函数的调用操作没什么区别。</p><p>普通函数会在执行完毕时返回，协程会在<strong>遇到第一个挂起点时</strong>或<strong>执行完毕时</strong>返回。</p><p>当调用一个协程的时候，调用者会分配新的栈帧，将调用参数压入栈中，将返回地址压入栈中，然后将执行转移到协程。</p><p>协程所做的第一件事情是在堆上分配协程帧，然后从栈帧中复制(copy)/移动(move)调用参数到协程帧中，以使得调用参数的生命周期超过第一个挂起点。</p><h1 id="协程的返回操作（The-‘Return’-opeartion-of-a-coroutine）"><a href="#协程的返回操作（The-‘Return’-opeartion-of-a-coroutine）" class="headerlink" title="协程的返回操作（The ‘Return’ opeartion of a coroutine）"></a>协程的返回操作（The ‘Return’ opeartion of a coroutine）</h1><p>当一个协程执行返回声明(return-statement)时（即 co_return 关键词），会将返回值储存在某个地方（这个地方可以自定义），然后销毁所有的局部变量（但是不包括调用参数）。</p><p>然后协程有机会在将执行转移回调用者/恢复者之前执行一些额外的逻辑。</p><p>这些额外的逻辑可能执行一些操作来发布返回值，或者恢复执行其他需要这个返回结果的协程。这是完全可自定义的。</p><p>然后协程要么执行挂起操作（保持协程帧存活），或者执行销毁操作（销毁协程帧）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;理解 C++20 Coroutine: 协程的概念。C++ coroutine 的细节非常的多，但是能查到的资料却不是很多。我一边学习一边记录，打算写很多篇文章来分享我的理解。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++17 特性:使用 std::string_view 时小心踩坑</title>
    <link href="https://uint128.com/2022/02/16/C-17-%E7%89%B9%E6%80%A7-%E4%BD%BF%E7%94%A8-std-string-view-%E6%97%B6%E5%B0%8F%E5%BF%83%E8%B8%A9%E5%9D%91/"/>
    <id>https://uint128.com/2022/02/16/C-17-%E7%89%B9%E6%80%A7-%E4%BD%BF%E7%94%A8-std-string-view-%E6%97%B6%E5%B0%8F%E5%BF%83%E8%B8%A9%E5%9D%91/</id>
    <published>2022-02-15T20:11:10.000Z</published>
    <updated>2023-01-08T13:22:57.314Z</updated>
    
    <content type="html"><![CDATA[<p>C++17 特性:使用 std::string_view 时小心踩坑<br><span id="more"></span></p><h1 id="关于-std-string-view"><a href="#关于-std-string-view" class="headerlink" title="关于 std::string_view"></a>关于 std::string_view</h1><p>使用 std::string_view 的原因是为了避免无意义的 std::string 临时对象。</p><p>比如说，有某个函数，需要支持 C++-Style 的字符串，即 std::string 和 C-Style 的字符串，即 const char* 两种风格的字符串。最省事的写法就是只写一个 C++-Style 的版本，当传入 C-Style 字符串时，编译器会调用 std::string 的构造函数，自动创建一个 std::string 的临时对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line">string text &#123; <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">func</span>(text);    <span class="comment">// works!</span></span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// works! 相当于: func(std::string(&quot;Hello&quot;));</span></span><br></pre></td></tr></table></figure><p>那么，如果这个函数会被经常调用，而你很在意这个临时对象，最好的方法是再写一个 C-Style 版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++-Style version:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C-Style version:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str[N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 将会调用 C-Style version</span></span><br></pre></td></tr></table></figure><p>写两个版本，临时对象的问题是解决了，但是这种解决方案并不那么优雅，这样做带来了更多的问题。</p><p>比如说，现在你需要维护两个版本的代码，它们的代码几乎一样。这个一般可以通过再实现一个 func_impl 函数来解决，也就是把具体实现挪到另一个函数。</p><p>又比如说，因为 func 的 C-Style 版本是模板函数，所以它的具体实现只能放到头文件里了。</p><p>那么 std::string_view 要如何“优雅地”解决问题呢？下面的代码使用 std::string_view 将 func 函数重写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string_view version</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::string_view str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(text);    <span class="comment">// works!</span></span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// works! 而且没有临时的 std::string 对象产生！</span></span><br></pre></td></tr></table></figure><p>很多教程或者书籍都会推荐这样一个做法，一个函数有 std::string 类型的参数，如果这个参数它不会被修改，那么应该以 const-reference 的方式传递。这也就是前面 C++-Style version 的写法: 使用 <code>const string&amp; str</code> 而不是 <code>string str</code>。<br>这样做是因为以值类型传参比以引用类型传参会多一次复制，这种复制的成本可能是高昂的，需要尽量避免。</p><p>但是也有例外，如果复制的成本很小，比如 int、double 这种简单的类型，复制的成本极低，使用引用传参甚至可能拖慢速度（比如可能阻止编译器做优化）。</p><p>这里的 std::string_view 就是这种复制成本很小的对象。所以虽然我们已经习惯了使用 <code>const string&amp;</code>，但是对于 std::string_view，最好不要使用引用传参，<strong>因为 std::string_view 的本质就是一个引用</strong>，使用引用的引用并不会带来更多的好处。</p><h1 id="容易踩坑的地方"><a href="#容易踩坑的地方" class="headerlink" title="容易踩坑的地方"></a>容易踩坑的地方</h1><h2 id="标准库生态不佳"><a href="#标准库生态不佳" class="headerlink" title="标准库生态不佳"></a>标准库生态不佳</h2><p>虽然 std::string_view 有着那么好的优点，但是想用 std::string_view 完全替代 <code>const string&amp;</code> 和 <code>const char[N]</code> 是不会顺利的。并不是简单地把 <code>const string&amp;</code> 替换成 std::string_view 就可以了。</p><p>比如说，标准库的正则表达式库 std::regex 对 std::string_view 的支持就不够好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://gist.github.com/WojciechMula/78f7b579abe77ebcfe38beae8d037e88</span></span><br><span class="line"><span class="function">std::vector&lt;std::string_view&gt; <span class="title">correct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;std::string_view&gt; result;</span><br><span class="line">  <span class="comment">// 没有 std::svmatch 这种东西，所以必须写全类型名称</span></span><br><span class="line">  std::match_results&lt;std::string_view::const_iterator&gt; match;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(input.<span class="built_in">cbegin</span>(), input.<span class="built_in">cend</span>(), match, re)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">1</span>; i &lt; match.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* first = match[i].first;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* last = match[i].second;</span><br><span class="line">      <span class="comment">// 必须根据长度自己构建 string_view 对象</span></span><br><span class="line">      result.<span class="built_in">push_back</span>(&#123;first, <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(last - first)&#125;);</span><br><span class="line">      <span class="comment">// *不要*写成：result.push_back(match[i].str());</span></span><br><span class="line">      <span class="comment">// match[i].str() 生成了临时的 string 对象</span></span><br><span class="line">      <span class="comment">// 而 string_view 的本质是引用</span></span><br><span class="line">      <span class="comment">// 一个指向临时对象的引用会导致程序出错崩溃的！</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又比如说常用的 string to int/long long 函数，std::stoi 和 std::stoll，它们并没有提供 string_view 版本。如果你一定要将字符串转换成数字，那么只能做出修改，使用 std::from_chars 替换 std::stoi/std::stoll。</p><h2 id="由字符串的本质引起的问题"><a href="#由字符串的本质引起的问题" class="headerlink" title="由字符串的本质引起的问题"></a>由字符串的本质引起的问题</h2><p>我有一个踩坑的案例可以分享。我有一个 string_view 对象，它的内容是一个 URL，我打算使用 std::regex 从中取出 hostname 和 port，这个过程没有什么问题，而且前面也分享了如何正确地对 string_view 对象使用 std::regex。</p><p>问题在于，我得到的两个对象：<code>std::string_view hostname;</code> 和 <code>std::string_view port;</code> <strong>它们实际储存的并不是字符串片段！</strong></p><p>字符串的本质就是以 ‘\0’ 结尾的 char 数组（或者宽字节 wchar 数组）。string_view 在内部也就是储存了这么一条数组的指针和一个长度。</p><blockquote><p>2023-01-08 Update。 我看到一种说法，觉得挺合适的：可以把 std::string_view 理解为不以 ‘\0’ 结尾的字符串，但所有的 C-Style API 都需要以 ‘\0’ 为结尾的字符串，这就是我出错的原因。</p></blockquote><p>那么当你调用某些需要 C-Style 字符串的 API 时，你可以没有任何开销的将 string_view 转换成 const char*，这么做的时候你不会有任何多余的想法，因为这确实是可行的，而且没有代价。</p><p>那么如果使用 C 语言的 printf 来打印 hostname 和 port，得到的结果将会是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string url &#123; <span class="string">&quot;ws://localhost:8080/chat&quot;</span> &#125;;</span><br><span class="line">std::string_view hostname = <span class="built_in">getHostname</span>(url);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hostname.<span class="built_in">data</span>());</span><br><span class="line"><span class="comment">// 实际运行结果: localhost:8080/chat</span></span><br><span class="line"><span class="comment">// 我期待的结果：localhost</span></span><br></pre></td></tr></table></figure><p>这就导致了我调用的 C API 一直出错，我还一头雾水，一时间反应不过来为什么出错。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++17 特性:使用 std::string_view 时小心踩坑&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 OpenCV 处理 esp32-cam 推流</title>
    <link href="https://uint128.com/2021/11/10/%E4%BD%BF%E7%94%A8OpenCV%E5%A4%84%E7%90%86esp32-cam%E6%8E%A8%E6%B5%81/"/>
    <id>https://uint128.com/2021/11/10/%E4%BD%BF%E7%94%A8OpenCV%E5%A4%84%E7%90%86esp32-cam%E6%8E%A8%E6%B5%81/</id>
    <published>2021-11-10T05:01:44.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>使用 OpenCV 处理 esp32-cam 推流<br><span id="more"></span></p><p>使用 Arduino 刷入 esp32-cam 的 CameraWebServer 示例，然后就可以通过访问 <a href="http://ip:80/">http://ip:80/</a> 进入控制页，或者访问 <a href="http://ip:81/stream">http://ip:81/stream</a> 获取“实时视频推流”。</p><p>但是这个视频推流并不是常见的视频格式，而是 jpg 图片流，这个可以抓包分析出来。</p><p>我在浏览器使用 F12 没法查看具体的响应，所以我用 Fiddler 进行抓包分析的。</p><p>我的 esp32-cam 响应的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\r\n</span><br><span class="line">--123456789000000000000987654321\r\n</span><br><span class="line">Content-Type: image/jpeg\r\n</span><br><span class="line">Content-Length: 5123</span><br><span class="line">\r\n</span><br><span class="line">\r\n</span><br><span class="line">/* 这里是jpg图片的二进制内容 */</span><br></pre></td></tr></table></figure><p>为了方便查看，我把响应中的\r\n都保留了，没有删去。</p><p>其中 Content-Length 的内容就是 jpg 图片的长度，所以要先把它的值取出来，然后才能往后取出 jpg 图片的内容。</p><p>我的需求是将这一张张 jpg 图片转化为 OpenCV 的 Mat 格式，这样就能使用 OpenCV 作进一步处理了。</p><p>因为这个推流是源源不断地进行的，OpenCV 的处理也是不断在进行的，这就需要用两个线程同时进行处理。一个线程不断获取 esp32 推流，另一个线程不断解析响应，并且用 OpenCV 处理响应中的 jpg 图片。另外，两个线程都要访问响应数据，如果同时访问响应数据，可能会出现 <a href="https://en.wikipedia.org/wiki/Race_condition">race condition</a>，所以还要<strong>考虑多线程同步</strong>。</p><p>我用 libcurl 库发起 HTTP 请求，这是使用 libcurl 发起请求部分的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">reWriter</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, string* content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizes = size * nmemb;</span><br><span class="line">    content-&gt;<span class="built_in">append</span>(buffer, sizes);</span><br><span class="line">    <span class="keyword">return</span> sizes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">curl_global_init</span>(CURL_GLOBAL_ALL);</span><br><span class="line">    CURL* curl;</span><br><span class="line">    curl = <span class="built_in">curl_easy_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// esp32-cam 推流的网址，改成自己的</span></span><br><span class="line">    string url = <span class="string">&quot;http://192.168.1.123:81/stream&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里使用 string 作为 buffer，比较方便</span></span><br><span class="line">    string buffer;</span><br><span class="line"></span><br><span class="line">    thread th = std::<span class="built_in">thread</span>([&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 开启跟随跳转, 这里没必要设置，抄代码的时候没删掉 */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_FOLLOWLOCATION, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">/* 设置超时时间(单位：秒)，不要太长，因为 esp32 的网络不太稳定，如果断连需要尽快重连 */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TIMEOUT, (<span class="type">long</span>)<span class="number">5LL</span>);</span><br><span class="line">            <span class="comment">/* 关闭 SSL 验证, 这里没必要设置，抄代码的时候没删掉 */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_VERIFYPEER, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_VERIFYHOST, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">/* enable TCP keep-alive for this transfer */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TCP_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">/* keep-alive idle time to 120 seconds */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TCP_KEEPIDLE, <span class="number">120L</span>);</span><br><span class="line">            <span class="comment">/* interval time between keep-alive probes: 60 seconds */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TCP_KEEPINTVL, <span class="number">60L</span>);</span><br><span class="line">            <span class="comment">// curl 数据处理函数</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, reWriter);</span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, (<span class="type">void</span>*)&amp;(buffer));</span><br><span class="line">            <span class="comment">// 设置处理HTTP头部的功能函数</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, url.<span class="built_in">data</span>());</span><br><span class="line">            <span class="comment">// 发起请求（会阻塞当前线程）</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;正在发起请求...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">curl_easy_perform</span>(curl);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;连接已经断开!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    th.<span class="built_in">detach</span>(); <span class="comment">// 让线程独立运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 处理响应</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 reWriter 函数是<strong>响应数据的处理函数</strong>，将接收到的响应数据存起来并返回其长度就好了。</p><p>响应的解析部分我直接在主线程进行，先使用正则表达式取出 Content-Length，然后再取出 jpg 图片的内容。</p><p>使用 string 作为 buffer 的好处就是可以用 substr 比较方便地取出其中的部分内容。</p><p>具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int64_t</span> buffer_length = buffer.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buffer_length: &quot;</span> &lt;&lt; buffer.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\r\n--123456789000000000000987654321\r\nContent-Type: image\/jpeg\r\nContent-Length: ([\\d]+)\r\n\r\n&quot;</span>)</span></span>;</span><br><span class="line">    smatch result;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">regex_search</span>(buffer, result, pattern)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int64_t</span> image_length = <span class="built_in">stoll</span>(result[<span class="number">1</span>].<span class="built_in">str</span>());</span><br><span class="line">    <span class="type">int64_t</span> header_length = result.<span class="built_in">length</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果图片完整地储存在 buffer 中，才读取图片的数据</span></span><br><span class="line">    <span class="keyword">if</span> (header_length + image_length &lt;= buffer_length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出 jpg 图片内容</span></span><br><span class="line">        string image_buffer = buffer.<span class="built_in">substr</span>(header_length, image_length);</span><br><span class="line">        <span class="comment">// 清除 buffer，这一步很关键</span></span><br><span class="line">        buffer.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 使用 OpenCV 读取 jpg 图片</span></span><br><span class="line">        Mat tmp = <span class="built_in">Mat</span>(<span class="number">1</span>, image_length, CV_8UC1, (<span class="type">void</span>*)image_buffer.<span class="built_in">data</span>());</span><br><span class="line">        cv::Mat decodedImage = <span class="built_in">imdecode</span>(tmp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (decodedImage.data != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 翻转 esp32-cam 传来的图片，根据需要删去或保留</span></span><br><span class="line">            Mat filped;</span><br><span class="line">            <span class="built_in">flip</span>(decodedImage, filped, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;display&quot;</span>, filped);</span><br><span class="line">            <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个步骤非常重要，就是<strong>每解析一张图片就清除 buffer</strong>。</p><p>我们接收到的 buffer 里，可能不止含有一份响应。一份响应里包含一个 HTTP 头部和一张 jpg 图片。</p><p>变量 buffer 里储存的内容，可能包含<strong>一份完整的响应</strong>和<strong>半份响应</strong>（半份响应：比如完整的 HTTP 头部和 jpg 图片的一部分内容，甚至只有一部分 HTTP 头部）。</p><p>正常来说，那<strong>半份响应</strong>应该保留在 buffer 中。等到接收到更多内容时再尝试解析，因为buffer中<strong>旧的内容</strong>加上<strong>新接收的内容</strong>可能就凑出了<strong>一份完整的响应</strong>。如果我们清除掉未解析的数据，会导致丢失掉一些数据！</p><p>但是我们的需求有点特殊，因为视频推流对实时性要求很高。我们不在意过去的每一帧内容，只在意当前 esp32-cam 看到的那一帧内容。</p><p>如果 esp32-cam 推流的速度大于我们解析的速度，那么 esp32-cam 推送的内容就会堆积在 buffer 变量中(因为 TCP 是可靠的协议，TCP 保证将 esp32-cam 发送到内容送达)。占用大量的内存不说，还会遇到<strong>累积延迟</strong>的问题。也就是说程序当前解析的一帧，其实发生在过去，表现就是画面的延迟。而且这种延迟是会累积的，随着时间的推移，延迟会越来越大。</p><p>所以如果我们解析的时候遇到了很多份响应(说明此时 esp32-cam 推流速度大于解析速度)，那么就应该只取其中的一份，其他的响应都丢弃，这样就不会有内容堆积在 buffer 中。</p><p>最后，主线程和 libcurl 的线程同时访问了变量 buffer，需要加锁控制。</p><p>考虑到只需要在 buffer 被修改后才需要解析 buffer，所以我还用上了条件变量(condition_variable)。</p><p>条件变量通常和 lock_guard/unique_lock 一起使用。它会释放锁并阻塞，直到另一个线程将 flag 变为 true，并发出通知后才继续执行。</p><p>修改后的完整程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">std::mutex mutex_buffer;</span><br><span class="line">std::condition_variable cv_buffer;</span><br><span class="line"><span class="comment">// flag: 表示是否有新数据到达</span></span><br><span class="line"><span class="type">bool</span> arrived = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">reWriter</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, string* content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizes = size * nmemb;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_buffer)</span></span>;</span><br><span class="line">        content-&gt;<span class="built_in">append</span>(buffer, sizes);</span><br><span class="line">    &#125;</span><br><span class="line">    arrived = <span class="literal">true</span>;</span><br><span class="line">    cv_buffer.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> sizes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">curl_global_init</span>(CURL_GLOBAL_ALL);</span><br><span class="line">    CURL* curl;</span><br><span class="line">    curl = <span class="built_in">curl_easy_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// esp32-cam 推流的网址，改成自己的</span></span><br><span class="line">    string url = <span class="string">&quot;http://192.168.1.123:81/stream&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里使用 string 作为 buffer，比较方便</span></span><br><span class="line">    string buffer;</span><br><span class="line"></span><br><span class="line">    thread th = std::<span class="built_in">thread</span>([&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 开启跟随跳转, 这里没必要设置，抄代码的时候没删掉 */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_FOLLOWLOCATION, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">/* 设置超时时间(单位：秒)，不要太长，因为 esp32 的网络不太稳定，如果断连需要尽快重连 */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TIMEOUT, (<span class="type">long</span>)<span class="number">5LL</span>);</span><br><span class="line">            <span class="comment">/* 关闭 SSL 验证, 这里没必要设置，抄代码的时候没删掉 */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_VERIFYPEER, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_VERIFYHOST, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">/* enable TCP keep-alive for this transfer */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TCP_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">/* keep-alive idle time to 120 seconds */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TCP_KEEPIDLE, <span class="number">120L</span>);</span><br><span class="line">            <span class="comment">/* interval time between keep-alive probes: 60 seconds */</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TCP_KEEPINTVL, <span class="number">60L</span>);</span><br><span class="line">            <span class="comment">// curl 数据处理函数</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, reWriter);</span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, (<span class="type">void</span>*)&amp;(buffer));</span><br><span class="line">            <span class="comment">// 设置处理HTTP头部的功能函数</span></span><br><span class="line">            <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, url.<span class="built_in">data</span>());</span><br><span class="line">            <span class="comment">// 发起请求（会阻塞当前线程）</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;正在发起请求...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">curl_easy_perform</span>(curl);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;连接已经断开!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    th.<span class="built_in">detach</span>(); <span class="comment">// 让线程独立运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_buffer)</span></span>;</span><br><span class="line">        cv_buffer.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> arrived; &#125;);</span><br><span class="line">        arrived = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int64_t</span> buffer_length = buffer.<span class="built_in">size</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;buffer_length: &quot;</span> &lt;&lt; buffer.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\r\n--123456789000000000000987654321\r\nContent-Type: image\/jpeg\r\nContent-Length: ([\\d]+)\r\n\r\n&quot;</span>)</span></span>;</span><br><span class="line">        smatch result;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">regex_search</span>(buffer, result, pattern)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int64_t</span> image_length = <span class="built_in">stoll</span>(result[<span class="number">1</span>].<span class="built_in">str</span>());</span><br><span class="line">        <span class="type">int64_t</span> header_length = result.<span class="built_in">length</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果图片完整地储存在 buffer 中，才读取图片的数据</span></span><br><span class="line">        <span class="keyword">if</span> (header_length + image_length &lt;= buffer_length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出 jpg 图片内容</span></span><br><span class="line">            string image_buffer = buffer.<span class="built_in">substr</span>(header_length, image_length);</span><br><span class="line">            <span class="comment">// 清除 buffer，这一步很关键</span></span><br><span class="line">            buffer.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// 使用 OpenCV 读取 jpg 图片</span></span><br><span class="line">            Mat tmp = <span class="built_in">Mat</span>(<span class="number">1</span>, image_length, CV_8UC1, (<span class="type">void</span>*)image_buffer.<span class="built_in">data</span>());</span><br><span class="line">            cv::Mat decodedImage = <span class="built_in">imdecode</span>(tmp, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (decodedImage.data != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 翻转 esp32-cam 传来的图片，根据需要删去或保留</span></span><br><span class="line">                Mat filped;</span><br><span class="line">                <span class="built_in">flip</span>(decodedImage, filped, <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">imshow</span>(<span class="string">&quot;display&quot;</span>, filped);</span><br><span class="line">                <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 OpenCV 处理 esp32-cam 推流&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2021电赛F题:送药小车-基于OpenCV和汉明距离识别数字思路</title>
    <link href="https://uint128.com/2021/11/09/2021%E7%94%B5%E8%B5%9BF%E9%A2%98-%E9%80%81%E8%8D%AF%E5%B0%8F%E8%BD%A6-%E5%9F%BA%E4%BA%8EOpenCV%E5%92%8C%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E8%AF%86%E5%88%AB%E6%95%B0%E5%AD%97%E6%80%9D%E8%B7%AF/"/>
    <id>https://uint128.com/2021/11/09/2021%E7%94%B5%E8%B5%9BF%E9%A2%98-%E9%80%81%E8%8D%AF%E5%B0%8F%E8%BD%A6-%E5%9F%BA%E4%BA%8EOpenCV%E5%92%8C%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E8%AF%86%E5%88%AB%E6%95%B0%E5%AD%97%E6%80%9D%E8%B7%AF/</id>
    <published>2021-11-09T06:40:32.000Z</published>
    <updated>2022-08-22T09:11:21.019Z</updated>
    
    <content type="html"><![CDATA[<p>这个题目挺好玩的，不过我并没有参赛，所以只尝试了我感兴趣的识别数字的部分。<br><span id="more"></span></p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>这个识别需求非常简单，一句话就能说完：识别摄像头拍摄到的数字，数字的样式如图所示，数字可能单独出现，也可能两个一组地出现，画面中最多并排出现两组数字，当有多个数字时，数字的顺序不能乱。</p><p><img src="QQ截图20211109145914.png" alt="要识别的数字的样式"></p><p>也就是说画面可能会有若干个<strong>带框的数字</strong>并排出现，我要做的就是识别出它们，而且顺序不能乱。</p><p>我注意到很多人立马想到用目标检测的方法来寻找画面中的数字和它的位置。但是我之前查阅过一些资料，目前很火热的目标检测算法 yolo 其实不擅长在画面中寻找文字符号（我想过用 yolo 来做 OCR 来着），所以我并没有和他们一样从目标检测这个方向来考虑。</p><p>我以前做过类似的工作 —— 识别图中的多边形（三角形、四边形）并找到它们的位置。而这次要识别的数字刚好也带一个四边形的框，所以我以前做过的工作直接就能用了。</p><p>最终我采用的是传统的计算机视觉方案。</p><h1 id="OpenCV-识别矩形并纠正透视变形"><a href="#OpenCV-识别矩形并纠正透视变形" class="headerlink" title="OpenCV 识别矩形并纠正透视变形"></a>OpenCV 识别矩形并纠正透视变形</h1><h2 id="识别矩形边框"><a href="#识别矩形边框" class="headerlink" title="识别矩形边框"></a>识别矩形边框</h2><p>其实更准确的说法是识别画面中的四边形，因为画面是带有畸变（镜头影响）和透视变形（拍摄角度影响）的，所以矩形的边框被摄像头拍下来后就是一个不太整齐的四边形了。</p><p>我把我以前做过的多边形识别改成了四边形识别，结果如下图。</p><p><img src="QQ截图20211109154433.png" alt="识别画面中的四边形"></p><p>可以看到问题还是挺多的。</p><p>比如数字的边框识别出了嵌套的两个边框而不是一个边框。这是因为数字边框的内边缘和外边缘被认为是两个四边形了。这个问题我的解决方法是找到所有两两嵌套的边框，然后删除外面那个边框。</p><p>还有一个问题就是把没有数字内容的四边形也识别出来了，我的思路是暂时不管它，等到识别数字的阶段，如果没找到数字就舍弃这个边框。</p><p>我这里就不贴代码了，因为我也是网上抄的，对其中的原理不是很了解。等我日后研究清楚了另发一篇博客分享。（挖坑）</p><h2 id="纠正透视变形"><a href="#纠正透视变形" class="headerlink" title="纠正透视变形"></a>纠正透视变形</h2><p>带有透视变形的数字可能不利于 OCR，所以最好是进行纠正。</p><p>这个纠正其实很常用，比如现在的手机拍照都有所谓的“文档模式”，它能自动搜索图片中的投影仪画面或者纸张，确定投影仪画面或者纸张的四个顶点，然后把图片裁剪成只有投影仪画面或者只有纸张的图片。</p><p>这部分代码也是抄的，就先不贴出来了，纠正后的效果如图所示，效果非常好。</p><p><img src="QQ图片20211109154854.png" alt="纠正透视变形"></p><h1 id="识别数字"><a href="#识别数字" class="headerlink" title="识别数字"></a>识别数字</h1><p>识别数字我并没有用什么神经网络，用的还是简单的方法。首先是这个数字是很标准的字体，又不是什么手写字体，杀鸡何须牛刀？其次我这个程序是用 C++ 写的，而平时玩神经网络都是用的 dotnet(ML.NET) 或者 python，C++ 程序调用它们不太方便。</p><p>我以前做过类似的识别工作，为了识别教务系统的验证码。那个验证码是很简单的：位置固定、标准字体、没有干扰线，所以我用的是最简单的汉明距离。</p><p>这次的数字识别和那个验证码识别非常类似，所以这次我也用的汉明距离。</p><p>在计算汉明距离之前，需要对图片进行预处理比如缩放为固定大小、转化为灰度图、二值化处理。预处理中尤其是要进行二值化，这样才方便计算汉明距离。</p><h2 id="灰度与二值化预处理"><a href="#灰度与二值化预处理" class="headerlink" title="灰度与二值化预处理"></a>灰度与二值化预处理</h2><p>效果如图所示。</p><p><img src="QQ图片20211109160901.png" alt="灰度和二值化处理后的数字"></p><h2 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h2><p>我之前做验证码识别的时候并没有提取特征。我从 A-Z 0-9 里各挑选一张照片，组成一个 36 张照片的数据库。然后拿新的照片和那 36 张图片算汉明距离，汉明距离最小的就认为是答案。</p><p>这次我打算用新的思路，这个思路是我以前看到的，忘了出处是哪里了，当时觉得很有意思所以一直记得。</p><p>这个思路就是从图片中提取一定的特征，然后算新图片特征和旧图片特征的汉明距离，这其中的关键是提取特征的算法。</p><p>我记到的特征提取算法简单来说就是数有几个像素点：</p><ol><li>首先横着走，数图片<strong>每一列</strong>有多少像素点；</li><li>然后竖着走，数图片<strong>每一行</strong>有多少像素点；</li></ol><p>对于 32x32 的图片，第一步和第二步分别得到 32 个数字，这两组数字称为一张图片的特征。</p><p>当时实现的提取特征的代码如下（注意！实现的代码有误！）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">float</span>&gt; <span class="title">calcIdX</span><span class="params">(<span class="type">const</span> Mat&amp; image_binary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">float</span>&gt; result;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_binary.cols; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image_binary.rows; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value = <span class="number">255</span> - (<span class="type">int</span>)image_binary.<span class="built_in">at</span>&lt;uchar&gt;(j, i);</span><br><span class="line">tmp += value;   <span class="comment">// !我没有除以 255，但是影响不大，下同</span></span><br><span class="line">&#125;</span><br><span class="line">result.<span class="built_in">push_back</span>((tmp / (<span class="type">float</span>)image_binary.rows)); <span class="comment">// !我不知道为什么我当时要除以 rows，但是影响不大，下同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">float</span>&gt; <span class="title">calcIdY</span><span class="params">(<span class="type">const</span> Mat&amp; image_binary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">float</span>&gt; result;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_binary.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image_binary.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value = <span class="number">255</span> - (<span class="type">int</span>)image_binary.<span class="built_in">at</span>&lt;uchar&gt;(i, j);</span><br><span class="line">tmp += value;</span><br><span class="line">&#125;</span><br><span class="line">result.<span class="built_in">push_back</span>((tmp / (<span class="type">float</span>)image_binary.cols));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我对 1~8 每个数字都挑选了十几个图片，计算了它们的<strong>平均特征值</strong>。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>算汉明距离就是算<strong>新的图片的特征值</strong>和<strong>平均特征值</strong>，有多少位置不一样。</p><p>虽然我知道是这样的，但是当时迷迷糊糊的状态写的代码求的根本不是汉明距离，真的不知道我当时在想什么。</p><p>前面求了 <strong>平均特征值</strong>，而且求的特征代码写错了，所以下面算的“汉明距离”也就不是“汉明距离了”，而是“相似度”的概念了。</p><p>我算“汉明距离”的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">float</span>&gt;&amp; id1, <span class="type">const</span> vector&lt;<span class="type">float</span>&gt;&amp; id2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; id1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">result += <span class="built_in">fabs</span>(id1[i] - id2[i]);    <span class="comment">// 这求的可不是汉明距离啊</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result / id1.<span class="built_in">size</span>(); <span class="comment">// 为什么我又除了个常数？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>连错两次，代码居然能按照预想的结果来……</p></blockquote><h1 id="实际应用效果"><a href="#实际应用效果" class="headerlink" title="实际应用效果"></a>实际应用效果</h1><p>朋友的小车用 esp32-cam 来实时录像并推流。我的程序只需要部署到一台和 esp32-cam 相同局域网的设备上就可以工作。</p><h2 id="OpenCV-处理-esp32-推流"><a href="#OpenCV-处理-esp32-推流" class="headerlink" title="OpenCV 处理 esp32 推流"></a>OpenCV 处理 esp32 推流</h2><p>这里有个小坑，就是 esp32 的推流不是视频流，而是 jpg 图片流，所以 opencv 无法直接处理。<br>我用 libcurl 库手动处理了下 esp32 的推流，并让 opencv 解析其中的 jpg 图片。</p><p>因为细节还挺多的，所以这部分的代码将在<a href="https://uint128.com/2021/11/10/%E4%BD%BF%E7%94%A8OpenCV%E5%A4%84%E7%90%86esp32-cam%E6%8E%A8%E6%B5%81/">另一篇博文</a>里分享。</p><h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>实际的工作结果还是比较好的，光线条件的影响不是很大，但是受视角的影响比较大。如果画面中数字的边框不完整，那么即使数字在画面中占比很大，我的程序也完全无法工作 —— 识别到矩形框是一切的前提，然后才能识别出数字。</p><p>但是 esp32-cam 的画面视角比较窄（朋友给换了个素质更好的镜头），实际测试中，两个数字同时出现在画面中，总有一个数字的边框贴近画面边缘，这就很危险了，说明这个方案稳定性可能不如预期。还好朋友调整了云台，让框尽量完整出现在画面中。</p><p>另一个问题就是 6 和 8 分不出来。8 可能会识别成 6，而 6 可能会识别成8，虽然错误率不是很高，但是这个问题说得上很致命了。我朋友的解决方案是对我提交的识别结果进行“滤波”，把出现提交最多的一次作为最终结果。</p><p>除了 6 和 8，其他数字的识别率还是比较高的，能有 90%。</p><h1 id="再分析"><a href="#再分析" class="headerlink" title="再分析"></a>再分析</h1><p>赛后我重点分析了下为什么我的方法分不清 6 和 8。</p><p>我怀疑是 6 和 8 的特征值太过相似，所以分不清。</p><p>我把它们的特征值做成曲线后，发现它们的特征曲线确实很像。</p><p><img src="untitled.jpg" alt="数字6和8的特征曲线"></p><p>如果不能对整体思路进行大改，应该可以通过修改求特征的算法来修补。毕竟我的求特征算法搞错了，说不定该对之后就可以工作了（懒得试）。</p><p>也可以增加新的特征，比如把 32x32 的图像横竖两刀切割为 4 份，对每一份都求两组特征值，再加上原来的两组特征值。总共 10 组特征值。</p><p>虽然运算量大了很多，但是应该应该对提升准确率有帮助（懒得试）。</p><h2 id="考虑改用-BP-神经网络"><a href="#考虑改用-BP-神经网络" class="headerlink" title="考虑改用 BP 神经网络"></a>考虑改用 BP 神经网络</h2><p>如果能写一个小型的 BP 神经网络，引入几个文件就能用的那种，用来做这种简单的分类任务应该会很好用。这次传统方法好用还是因为字体比较标准，如果是手写字体，我想还是机器学习那一套更好用，应该能节约很多工作量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个题目挺好玩的，不过我并没有参赛，所以只尝试了我感兴趣的识别数字的部分。&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://uint128.com/tags/c/"/>
    
    <category term="opencv" scheme="https://uint128.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>使用Fiddler在WSA(Windows安卓子系统)上抓包</title>
    <link href="https://uint128.com/2021/11/03/%E4%BD%BF%E7%94%A8Fiddler%E5%9C%A8WSA-Windows%E5%AE%89%E5%8D%93%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%8A%E6%8A%93%E5%8C%85/"/>
    <id>https://uint128.com/2021/11/03/%E4%BD%BF%E7%94%A8Fiddler%E5%9C%A8WSA-Windows%E5%AE%89%E5%8D%93%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%8A%E6%8A%93%E5%8C%85/</id>
    <published>2021-11-03T12:26:20.000Z</published>
    <updated>2022-08-22T09:11:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>使用Fiddler在WSA(Windows安卓子系统)上抓包。<br><span id="more"></span></p><h1 id="为什么选择-WSA？"><a href="#为什么选择-WSA？" class="headerlink" title="为什么选择 WSA？"></a>为什么选择 WSA？</h1><p>因为逆向分析的需要，很多逆向分析的工具都需要 Root 权限。<strong>使用 WSA 进行逆向分析的优势之一是摆脱了实体机的限制。</strong>在实体机上获取 Root 权限、安装 Xposed 框架都是比较困难的，会受到手机品牌厂商的限制。在 Android 手机越来越封闭的趋势下，连为发烧而生的 MIUI 也做出很多限制。在 MIUI 系统上解锁 Bootloader、获取 Root 权限需要获得内测资格，而获取内测资格需要给 MIUI 社区打工（每周提交 BUG），非常麻烦。</p><p>在虚拟机上进行逆向分析就会好很多，因为很多虚拟机一般都已经提供了 Root 权限。但是 Windows 平台的 X86 虚拟机一般不能运行只有 ARM ABI 的 APP（比如<strong>今日校园</strong>，在 x86 Android 上运行会闪退，因为它只提供了 ARM ABI）。为了解决这个问题，我只能在手机上创建 Android 虚拟机（VMOS Pro）来进行逆向分析。<strong>使用 WSA 进行逆向分析的第二个好处就是 WSA 可以将 ARM 指令转译为 x86 指令，从而能够运行这些只有 ARM ABI 的程序（而且效率不低，可以很流畅）。</strong></p><p>此外，常用的虚拟机的 Android 版本都比较低，常见的 Android 版本有 Android 5 和 Android 7。这个目前没有造成什么影响，但是 APP 完全可以通过提高最低版本来增加逆向难度，比如限制只能在 Android 10 以及以上版本的系统上运行。<strong>而 WSA 的版本是 Android 11，是比较新的版本。</strong>刚好 Android 12 也已经推出了，后续还可能有机会升级到 Android 12</p><p><img src="屏幕截图 2021-11-03 210430.png" alt="WSA设置页面"></p><h1 id="Fiddler-简要介绍"><a href="#Fiddler-简要介绍" class="headerlink" title="Fiddler 简要介绍"></a>Fiddler 简要介绍</h1><p>Fiddler Classic 是一个免费的 Windows 平台抓包软件，适用于抓取、分析 HTTP(S) 协议（但是不支持 HTTP/2）。</p><p>Fiddler 的原理是创建一个代理服务器，这样经过代理服务器的 HTTP(S) 协议数据包就都能被捕获了。对于 HTTPS 需要安装 Fiddler 的根证书，才能解密出原文。</p><p>说实话这个软件不是最好的软件，因为它还挺容易崩溃的。但是这个软件免费，而且用法简单。只要装上证书、设置好代理就能用。所以我常用来作快速分析。</p><h1 id="在-WSA-上使用-Fiddler"><a href="#在-WSA-上使用-Fiddler" class="headerlink" title="在 WSA 上使用 Fiddler"></a>在 WSA 上使用 Fiddler</h1><p>这里 Fiddler 的下载和安装就不过多介绍了，都是一些基本操作。获取 Fiddler 的下载地址还需要提供一个邮箱，可以使用十分钟邮箱接收下载地址。</p><h2 id="配置-Fiddler"><a href="#配置-Fiddler" class="headerlink" title="配置 Fiddler"></a>配置 Fiddler</h2><p>在菜单栏点击 <strong>Tools/Options</strong> 打开 Fiddler 的设置页面。</p><p>按照如图所示，在 <strong>HTTPS 页面</strong> 勾选<strong>Capture HTTPS CONNECTS</strong> 和 <strong>Decrypt HTTPS traffic</strong> 启用 Fiddler 的解析 HTTPS 协议的功能。</p><p><img src="QQ截图20211103213138.png" alt=""></p><p>另外在 <strong>Connections 页面</strong> 勾选 <strong>Allow remote computers to connect</strong> 以允许远程计算机连接 Fiddler 的代理服务器。</p><p>留意一下 Fiddler 代理的端口，后面要用到这个端口，一般来说默认是 <strong>8888</strong>。</p><p><img src="QQ截图20211103213154.png" alt=""></p><h2 id="配置-WSA"><a href="#配置-WSA" class="headerlink" title="配置 WSA"></a>配置 WSA</h2><p>WSA 联网的原理和其他的虚拟机是一样的，都是通过一个“虚拟出来的 Wifi 连接”联网的。</p><p>因此只要给这个 Wifi 设置代理，就可以抓取所有 APP 的数据包了。</p><p>要打开 WSA 的 Wifi 设置页面，你可以用 ADB 指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n com.android.settings/com.android.settings.Settings</span><br></pre></td></tr></table></figure><p>也可以用一个比较受欢迎的工具箱 <a href="https://github.com/makazeu/WsaToolbox">WSAToolBox</a>。</p><p><img src="QQ截图20211103213951.png" alt=""></p><p>然后如图修改 Wifi 的代理设置。代理的 IP 地址即网关的地址，端口即上面 Fiddler 设置页面显示的端口（默认为 <strong>8888</strong>）。</p><p><img src="屏幕截图 2021-11-03 212801.png" alt=""></p><p>为了避免 Windows 程序的数据包刷屏，可以点一下 Fiddler 左下角的 Capturing，让它不再显示，这个开关不影响远程连接，只会不再捕获 Windows 程序的数据包。</p><h1 id="抓取-HTTPS-包"><a href="#抓取-HTTPS-包" class="headerlink" title="抓取 HTTPS 包"></a>抓取 HTTPS 包</h1><p>至此，虽然可以通过 Fiddler 进行抓包，但是你的 App 很可能处于“断网状态”。而且 Fiddler 也无法看到数据包的明文。这是因为目前大多数 App 都已经通过 HTTPS 协议进行通讯。</p><p>HTTPS 的出现就是为了解决 HTTP 明文传输，容易被中间人查看、修改数据造成的信任问题，刚好 Fiddler 就是这样的中间人角色。</p><p>要让 Fiddler 能够看到 APP 发出的数据包的明文，需要安装 Fiddler 的根证书。</p><p>在高版本 Android 上安装根证书是比较麻烦的。在 Android 7 以下的版本，只需要在设置里安装一下就可以了。从 Android 7 开始，证书会被分为系统证书和用户证书，而且 App 默认是不信任用户安装的证书的。要把证书安装到系统证书，需要获得 <strong>/system</strong> 的读写权限，把证书写入到 <strong>/system/etc/security/cacerts</strong> 中。</p><p>网上有很多安装系统根证书的教程，但是可能不适用于 WSA(我试过一些教程，但是失败了)。所以我推荐一种新的方法，那就是使用 <a href="https://github.com/NVISOsecurity/MagiskTrustUserCerts">MagiskTrustUserCerts</a>。这个 Magisk 模块会在每次开机时把用户证书移动到系统证书里。也就是说，使用这个模块之后，只需要安装用户证书，然后重启，用户证书就变成系统证书从而被所有 App 信任了。</p><h2 id="安装-Magisk-和-LSPosed"><a href="#安装-Magisk-和-LSPosed" class="headerlink" title="安装 Magisk 和 LSPosed"></a>安装 Magisk 和 LSPosed</h2><p>这个部分的教程很可能会随着大佬对 WSA 的探索而更新，所以我不打算把它翻译到这里，读者可以在 <a href="https://github.com/LSPosed/MagiskOnWSA">MagiskOnWSA</a> 找到如何将 Magisk 和 LSPosed 安装到 WSA。</p><p>在这之后，不要忘了安装上面提到的 MagiskTrustUserCerts 模块。</p><h2 id="安装-Fiddler-根证书为系统证书"><a href="#安装-Fiddler-根证书为系统证书" class="headerlink" title="安装 Fiddler 根证书为系统证书"></a>安装 Fiddler 根证书为系统证书</h2><p>可以在 Windows 的浏览器里访问 <code>http://127.0.0.1:8888</code> 下载 Fiddler 的根证书，把它传输到 WSA里。<br>然后在 <strong>Android 设置页面 / 安全 / 加密与凭据 / 从SD卡安装</strong> 里安装 Fiddler 根证书。</p><p>重启 WSA 后，Fiddler 的根证书应该就被移动到 系统根证书里了。</p><h2 id="解决-SSL-Pinning"><a href="#解决-SSL-Pinning" class="headerlink" title="解决 SSL Pinning"></a>解决 SSL Pinning</h2><p>不少 APP 都使用了 SSL Pinning，也就是只信任自己设置的根证书，那么上面设置的系统根证书就对这个 APP 无效了。<br>要绕开这个限制，可以使用一个 Xposed 模块，<a href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe</a>。</p><p>装好 JustTrustMe 后，在LSPosed 里启用它，就可以抓取大多数 APP 数据包并进行分析了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我对一些概念不是很了解，尤其是 HTTPS 和 SSL Pinning 相关的知识了解甚少。如果本文有什么错误或者细节需要补充，希望各位大佬指出。</p><h2 id="编辑记录"><a href="#编辑记录" class="headerlink" title="编辑记录"></a>编辑记录</h2><p>2020-11-03: init</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Fiddler在WSA(Windows安卓子系统)上抓包。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
