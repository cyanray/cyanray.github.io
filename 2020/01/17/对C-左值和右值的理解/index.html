<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>对C++左值和右值的理解 - uint128&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="uint128&#039;s Blog"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="uint128&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="对C++左值和右值的理解"><meta property="og:type" content="blog"><meta property="og:title" content="对C++左值和右值的理解"><meta property="og:url" content="https://uint128.com/2020/01/17/%E5%AF%B9C-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3/"><meta property="og:site_name" content="uint128&#039;s Blog"><meta property="og:description" content="对C++左值和右值的理解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://uint128.com/2020/01/17/%E5%AF%B9C-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3/img-1.png"><meta property="article:published_time" content="2020-01-17T09:05:07.000Z"><meta property="article:modified_time" content="2022-08-22T09:11:21.035Z"><meta property="article:author" content="uint128.com"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="./img-1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://uint128.com/2020/01/17/%E5%AF%B9C-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3/"},"headline":"uint128's Blog","image":["https://uint128.com/2020/01/17/%E5%AF%B9C-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3/img-1.png"],"datePublished":"2020-01-17T09:05:07.000Z","dateModified":"2022-08-22T09:11:21.035Z","author":{"@type":"Person","name":"uint128.com"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"对C++左值和右值的理解"}</script><link rel="canonical" href="https://uint128.com/2020/01/17/%E5%AF%B9C-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3/"><link rel="alternate" href="/atom.xml" title="uint128&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">uint128&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/cyanray"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-01-17T09:05:07.000Z" title="2020/1/17 17:05:07">2020-01-17</time>发表</span><span class="level-item"><time dateTime="2022-08-22T09:11:21.035Z" title="2022/8/22 17:11:21">2022-08-22</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile">对C++左值和右值的理解</h1><div class="content"><p>对C++左值和右值的理解<br><span id="more"></span></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h1 id="左值和右值的定义"><a href="#左值和右值的定义" class="headerlink" title="左值和右值的定义"></a>左值和右值的定义</h1><h2 id="C-03标准中的左值和右值"><a href="#C-03标准中的左值和右值" class="headerlink" title="C++03标准中的左值和右值"></a>C++03标准中的左值和右值</h2><p>&emsp;&emsp;左值 (lvalue) 和右值 (rvalue) 中的“左”和“右”其实就是左手右手中的“左”和“右”。因为最初产生这个概念的时候，左值总是出现在赋值符号的左边，右值总是出现在赋值符号的右边。在C++03标准中，左值和右值是这样定义的：</p>
<blockquote>
<p>1.Every expression is either an lvalue or an rvalue.<br>2.An lvalue refers to an object or function.<br>……<br>5.The result of calling a function that does not return a reference is an rvalue. User deﬁned operators are functions, and whether such operators expect or yield lvalues is determined by their parameter and return types. </p>
</blockquote>
<p>&emsp;&emsp;即：对于每一个表达式，它要么是左值要么是右值。左值指向一个对象或函数。函数的返回值如果不是个引用，那么是个右值。用户定义的运算符是函数，此类运算符是期望值还是产生左值取决于其参数和返回类型。</p>
<p>&emsp;&emsp;左值是一个对象，这个对象占据了内存中的空间，并且可以取得地址。而如果一个表达式它不是左值，那么就认为这个表达式是一个右值。</p>
<p>&emsp;&emsp;借助代码也许会更好理解。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = (<span class="number">9</span> + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *pa = &amp;a;</span><br><span class="line">(<span class="number">9</span> + <span class="number">1</span>) = a;            <span class="comment">// 这一句代码是错误的，MSVC会提示：“表达式必须是可修改的左值”。</span></span><br><span class="line"><span class="type">int</span> *pb = &amp;(<span class="number">9</span> + <span class="number">1</span>);     <span class="comment">// 这一句代码是错误的，MSVC会提示：“表达式必须为左值或函数指示符”。</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;上面的代码中，变量a显然是一个左值，它可以出现在赋值符号的左边，也可以取得它的地址。而对于表达式 “(9 + 1)” 来说，它是一个临时的计算结果，它完全可能不存在于内存中（比如存在于某个临时寄存器中），也就是没有一个确定的内存地址，因此这个表达式不是一个左值，而是一个右值。只能给左值赋值，因为对一个不存在的内存赋值，是没有意义的。同样的道理，只能对左值取地址，因为对一个不存在地址的表达式取地址，是没有意义的。</p>
<p>&emsp;&emsp;前面提到在以前左值总是出现在赋值符号的左边，右值总是出现在赋值符号的右边。现在这个说法已经不那么准确，接下来谈谈两种特殊的情况。</p>
<p>&emsp;&emsp;左值未必能放在等号左边。考虑下面这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// a是一个左值</span></span><br><span class="line">a = <span class="number">100</span>;            <span class="comment">// 错误！a不能放在等号左边！</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;变量a显然是个左值，但是因为它被 const 修饰，不可被修改，所以变量a不能出现在赋值符号的左边。对于可以修改的左值，一般称为 <strong>“可修改左值”</strong>。</p>
<p>&emsp;&emsp;等号的左边未必是左值。考虑下面这一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>() = <span class="number">5321</span>; <span class="comment">// 语句1 可以运行，因为这一句代码相当于 func1().operator=(5321); </span></span><br><span class="line">    <span class="built_in">func2</span>() = <span class="number">4321</span>; <span class="comment">// 语句2 错误，MSVC会提示：“表达式必须是可修改的左值”</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从定义来看，函数 func1 和 func2 的返回值不是引用，所以是右值。而对一个右值赋值是无意义的，所以“语句 2”是错误的。但是因为 func1 返回的是类型A，这个类型重载了自己的赋值操作符。因此对它的赋值操作实际上等同于执行了成员函数 “operator=”，所以“语句 1”是可以运行的。</p>
<h2 id="C-11标准中的左值和右值"><a href="#C-11标准中的左值和右值" class="headerlink" title="C++11标准中的左值和右值"></a>C++11标准中的左值和右值</h2><p>&emsp;&emsp;C++11标准中的左值和右值明显复杂了许多。在C++11标准中，表达式可以分为广义左值 (glvalue, generalized lvalue)和右值(rvalue)。广义左值又可分为左值(lvalue)和消亡值(xvalue, eXpiring value)。右值又可分为消亡值(这里没有打错，它既是广义左值也是右值)和纯右值(prvalue, pure rvalue)。下面这幅图直观地说明了它们之间的关系。</p>
<p><img src="./img-1.png" alt=""></p>
<p>&emsp;&emsp;C++11标准中对它们的定义是：</p>
<blockquote>
<p>1.An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object.<br>2.An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2). [Example: The result of calling a function whose return type is an rvalue reference is an xvalue. —end example]<br>3.A glvalue (“generalized” lvalue) is an lvalue or an xvalue.<br>4.An rvalue (so called, historically, because rvalues could appear on the right-hand side of anassignment expression) is an xvalue, a temporary object(12.2) or subobject thereof, or a value that is not associated with an object.<br>5.A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue. —end example]</p>
</blockquote>
<p>&emsp;&emsp;C++11中左值(lvalue)的定义和C++03中的左值定义差不多。纯右值的定义依然是用“排除法”的方式定义，即：“不是消亡值就是纯右值”，关键在于这个消亡值(xvalue)。</p>
<p>&emsp;&emsp;按照定义的意思，消亡值也指向了一个对象，因为这个对象通常接近它生命周期的末期(也就是即将被销毁)，所以把它叫做消亡值。很好理解为什么消亡值是“广义上的左值”，其实就因为它指向了一个对象。</p>
<p>&emsp;&emsp;纯右值和C++03的右值很相似，比如字面值(如12, 3.14f, true)、函数的返回值(不是引用)都是纯右值。需要注意的是，C++规定字符串(const char*)是左值，而不是右值，虽然字符串也是字面值。(对此我的理解是:字符串是可以取得地址的，因此它至少是个“广义上的左值”)</p>
<h1 id="左值与右值之间的转换"><a href="#左值与右值之间的转换" class="headerlink" title="左值与右值之间的转换"></a>左值与右值之间的转换</h1><p>&emsp;&emsp;如果某个表达式期待一个右值，但是却给了一个左值，那么这个左值会被转换成右值。考虑下面这一段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">9</span>;       <span class="comment">// 变量a是一个左值</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;       <span class="comment">// 变量b是一个左值</span></span><br><span class="line"><span class="type">int</span> c = a + b;   <span class="comment">// 加法运算需要一个右值，左值b被转换成右值</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;正如注释中所述，变量a和变量b都是左值，而加法运算需要一个右值，所以变量b会被隐式地转换成右值。<br>&emsp;&emsp;但是这可不意味着可以反过来把右值转换成左值，这就不符合左值的定义了。但右值转换成左值也不总是不成立，考虑下面这一段代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;      <span class="comment">// 行得通，(p + 1)是右值，但是*(p + 1)是左值</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这一段代码中，<strong>(p + 1)</strong> 计算的结果是一个临时值，但是操作符 <strong>*</strong> 可以使 <strong>(p + 1)</strong> 变为左值，所以 <strong>*(p + 1)</strong> 可以出现在赋值符号的左侧。<br>&emsp;&emsp;反过来，操作符 <strong>&amp;</strong> 则可以将左值转换成右值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* bad_addr = &amp;(var + <span class="number">1</span>);     <span class="comment">// 错误：&amp; 操作符需要一个左值</span></span><br><span class="line"><span class="type">int</span>* addr = &amp;var;               <span class="comment">// 可行：var是一个左值</span></span><br><span class="line">&amp;var = <span class="number">40</span>;                      <span class="comment">// 错误：赋值符号左侧需要一个左值</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;符号 <strong>&amp;</strong> 的另一个作用是定义 <strong>“左值引用”</strong>，下面一段代码定义了一个左值引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在上面这一段代码中，变量a是一个左值，而变量b是a的 <strong>“左值引用”</strong>。不能给 <strong>非常量左值引用</strong> 赋予一个右值，因为这会产生从右值到左值的转换。但是 <strong>常量左值引用</strong> 则可以被赋予右值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string&amp; str1 = <span class="built_in">string</span>();        <span class="comment">// 错误:不能给“非常量左值引用”赋予右值</span></span><br><span class="line"><span class="type">const</span> string&amp; str2 = <span class="built_in">string</span>();  <span class="comment">// 可行：可以给常量左值引用赋予右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>;   <span class="comment">// 函数func的参数类型是“常量左值引用”</span></span><br><span class="line">string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">func</span>(str);                      <span class="comment">// 可行，可以把左值赋值给“常量左值引用”</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">string</span>(<span class="string">&quot;Hi!&quot;</span>));            <span class="comment">// 可行，虽然string(&quot;Hi!&quot;)是右值，但是也可以赋值给“常量左值引用”</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;上面这段代码演示了C++中一个很常见的优化方法，即按引用传参。从左值和右值的角度来看，这样做之所以行得通是因为左值和右值都可以赋值给“常量左值引用”。</p>
<h1 id="CV限定下的左值和右值"><a href="#CV限定下的左值和右值" class="headerlink" title="CV限定下的左值和右值"></a>CV限定下的左值和右值</h1><p>&emsp;&emsp;CV限定(cv-qualified) 这个术语指的是 <strong>const</strong> 和 <strong>volatile</strong> 两个类型限定符。按照C++中的定义，每一个没有被 <strong>const</strong> 和 <strong>volatile</strong> 的完成类型、未完成类型和 void 类型都有相应的三个 <strong>CV限定</strong> 版本的类型。举个例子，<strong>int</strong> 这个类型有三个 <strong>CV限定</strong> 版本的类型，分别是 <strong>const int</strong>、<strong>volatile int</strong> 和 <strong>const volatile int</strong>。<br>&emsp;&emsp;在C语言里，只有左值有CV类型限定符而右值不会有。在C++中，<strong>类的右值</strong> 可以有CV限定，但是内建类型(比如 int)没有。考虑下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的代码直接使用了参考文献[3]中的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo() const\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>().<span class="built_in">foo</span>();  <span class="comment">// 调用 foo</span></span><br><span class="line">    <span class="built_in">cbar</span>().<span class="built_in">foo</span>(); <span class="comment">// 调用 foo const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在 <strong>main</strong> 函数中 对 <strong>foo</strong> 函数的第二次调用，实际上调用的是 <strong>A类</strong> 中的 <strong>void foo() const</strong>方法。因为函数 <strong>cbar</strong> 返回的是 <strong>const A</strong>。<strong>const A</strong> 和 <strong>A</strong> 不是同一个类型。</p>
<h1 id="右值引用与移动语义"><a href="#右值引用与移动语义" class="headerlink" title="右值引用与移动语义"></a>右值引用与移动语义</h1><p>&emsp;&emsp;右值引用就是对右值的引用，这个特性在C++11标准中引入。符号 <strong>&amp;</strong> 可以声明 <strong>左值引用</strong>，对于右值引用则使用符号 <strong>&amp;&amp;</strong> 声明。<br>&emsp;&emsp;加入右值引用的特性是为了实现 <strong>移动语义(move semantic)</strong> 和 <strong>精确转发(perfect forwarding)</strong>。这一节只简单地谈一下移动语义。(因为我也只是懂得那么点)<br>&emsp;&emsp;要理解 <strong>移动语义</strong> 这个概念，最好还是结合一个实际的例子。考虑需要实现一个边长数组的类(类似std::vector)。<br>在实现赋值语句操作符的时候，可能会有这种实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的代码直接使用了参考文献[3]中的代码</span></span><br><span class="line">Intvec&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Intvec&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    Intvec <span class="built_in">tmp</span>(other);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_size, tmp.m_size);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_data, tmp.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这个实现对传入的 <strong>other</strong> 对象做了一个完全的拷贝，也就是创造了个副本 <strong>tmp</strong>。然后，将自己的成员变量和副本 <strong>tmp</strong> 交换。在这个函数结束的时候，自己原本的数据随着 <strong>tmp</strong> 的析构而销毁，并拥有了和 <strong>other</strong> 对象完全一样的新数据。使用它的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intvec <span class="title">v1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">Intvec v2;</span><br><span class="line"></span><br><span class="line">v2 = v1;            <span class="comment">// 语句1 : 给v2赋值一个左值</span></span><br><span class="line">v2 = <span class="built_in">Intvec</span>(<span class="number">30</span>);    <span class="comment">// 语句2 : 给v2赋值一个右值</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;对于 <strong>语句1</strong> 可以认为是确实需要一个和v1一模一样的副本，所以上面的代码完全没有问题。但是对于 <strong>语句2</strong>，也就是把一个右值赋值给v2，会发生什么？<br>&emsp;&emsp;首先 <strong>Intvec(30)</strong> 这个表达式会调用 <strong>Intvec</strong> 类的构造函数，创造一个 <strong>Intvec</strong> 对象，为了方便说明，可以称他为 <strong>临时对象1</strong>。<br>&emsp;&emsp;然后，调用 <strong>v2.operator=(const Intvec&amp; other)</strong>，把 <strong>临时对象1</strong> 传递进去。(虽然这个函数的参数要求是 <strong>常量左值引用</strong> 而 <strong>临时对象1</strong> 是个右值，但是上文已经说明这样做是合法的，这里没有问题。)<br>&emsp;&emsp;之后，这个函数(<strong>v2.operator=</strong>)对传入的参数 <strong>other</strong>，做了一个完全的复制，得到 <strong>临时对象2</strong> ，也就是副本 <strong>tmp</strong>。<br>&emsp;&emsp;到这里我想可以停止说明了。这短短一行代码，居然创建了两个临时对象！然而这真的有必要吗？考虑加入下面这个代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的代码直接使用了参考文献[3]中的代码</span></span><br><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;move assignment operator&quot;</span>);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_size, other.m_size);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_data, other.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这里的赋值语句操作符的参数和上一个有所不同。这里的参数类型是一个 <strong>右值引用</strong>，而上一个是 <strong>常量左值引用</strong>。区别在于，当编译器检测到参数是右值是，编译器会调用这个参数为 <strong>右值引用</strong> 版本的赋值语句操作符函数，而不是上一个版本的函数。也就是说，上面用例中的 <strong>语句2</strong> 将会调用这个新的 <strong>Intvec&amp; operator=(Intvec&amp;&amp; other)</strong> 函数(语句1没有变化，因为语句1的参数v1是个左值)。<br>&emsp;&emsp;另一个主要区别是，这个版本的函数没有了创造副本 <strong>tmp</strong> 的过程。这是因为副本 <strong>tmp</strong> 的使命只有两个：1.将other完全复制一份 2.在析构的时候把旧的数据给销毁。副本 <strong>tmp</strong> 能够做到第二个使命是因为它是一个临时变量，在函数结束的时候就会被析构，所以它是“濒临死期”。而传入参数的右值也是如此。在语句2(<strong>“v2 = Intvec(30);”</strong>)执行完后，这个 <strong>临时对象1</strong> 就会被析构，它也是“濒临死期”。还记得上文讲到的“消亡值”吗，消亡值指的就是即将消亡的值，实际上这里的other参数就是个消亡值。<br>&emsp;&emsp;利用这一点，就没有必要再创造一个副本 <strong>tmp</strong> 。<strong>临时对象1</strong> 拥有需要的新数据，同时它又即将消亡，能够代替副本 <strong>tmp</strong> 完成那两个使命。所以直接和 <strong>临时对象1</strong> 交换新旧数据就可以了，而不需要一个副本 <strong>tmp</strong> 作为中介。为了能够修改右值，C++11引入了右值引用。将旧数据移动到右值中，将右值中的数据移动给自己，使用“移动数据”代替“复制数据”，这就称为“移动语义”。(个人理解)</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf</a><br>[2] <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf</a><br>[3] <a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c">https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c</a><br>[4] <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>对C++左值和右值的理解</p><p><a href="https://uint128.com/2020/01/17/对C-左值和右值的理解/">https://uint128.com/2020/01/17/对C-左值和右值的理解/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>uint128.com</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-01-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/01/21/2048-%E6%B8%B8%E6%88%8FAI%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2048 游戏AI的实现思路</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/01/06/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/"><span class="level-item">学校教务系统登录前端加密分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "2c49e42ce8620dbe745256be74c798d9",
            repo: "cyanray.github.io",
            owner: "cyanray",
            clientID: "53e3c578fcb7b7b1a4da",
            clientSecret: "74433ee77d6e13fd635b82add519e143ac791726",
            admin: ["cyanray"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#左值和右值的定义"><span class="level-left"><span class="level-item">1</span><span class="level-item">左值和右值的定义</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#C-03标准中的左值和右值"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">C++03标准中的左值和右值</span></span></a></li><li><a class="level is-mobile" href="#C-11标准中的左值和右值"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">C++11标准中的左值和右值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#左值与右值之间的转换"><span class="level-left"><span class="level-item">2</span><span class="level-item">左值与右值之间的转换</span></span></a></li><li><a class="level is-mobile" href="#CV限定下的左值和右值"><span class="level-left"><span class="level-item">3</span><span class="level-item">CV限定下的左值和右值</span></span></a></li><li><a class="level is-mobile" href="#右值引用与移动语义"><span class="level-left"><span class="level-item">4</span><span class="level-item">右值引用与移动语义</span></span></a></li><li><a class="level is-mobile" href="#参考文献"><span class="level-left"><span class="level-item">5</span><span class="level-item">参考文献</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-29T09:02:24.000Z">2023-04-29</time></p><p class="title"><a href="/2023/04/29/C-Concepts-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7/">C++ Concepts 的两个技巧</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-16T17:24:21.000Z">2023-03-17</time></p><p class="title"><a href="/2023/03/17/%E7%8C%AB%E5%A8%98-NNLL-UINT128/">猫娘 NNLL - UINT128</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-06T15:23:32.000Z">2023-03-06</time></p><p class="title"><a href="/2023/03/06/Modern-CMake-%E5%AE%9E%E8%B7%B5/">Modern CMake 实践</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-07T18:40:09.000Z">2023-01-08</time></p><p class="title"><a href="/2023/01/08/%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/">牛顿插值法的 Matlab 实现</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-07T18:38:42.000Z">2023-01-08</time></p><p class="title"><a href="/2023/01/08/%E5%A4%9A%E5%85%83%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84-Matlab-%E5%AE%9E%E7%8E%B0/">多元牛顿迭代法的 Matlab 实现</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://yuanxingxing-yxx.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">星星的博客</span></span><span class="level-right"><span class="level-item tag">yuanxingxing-yxx.github.io</span></span></a></li><li><a class="level is-mobile" href="http://quosimodo.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">卡西莫多の礼物</span></span><span class="level-right"><span class="level-item tag">quosimodo.cn</span></span></a></li><li><a class="level is-mobile" href="https://blog.icepie.net/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">icepie&#039;s blog</span></span><span class="level-right"><span class="level-item tag">blog.icepie.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/sherlson" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">sherlson&#039;s blog</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="http://blog.devilwst.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">小生的技术成长路线</span></span><span class="level-right"><span class="level-item tag">blog.devilwst.top</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">uint128&#039;s Blog</a><p class="is-size-7"><span>&copy; 2023 uint128.com</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>